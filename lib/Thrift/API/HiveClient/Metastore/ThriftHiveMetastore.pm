#
# Autogenerated by Thrift Compiler (0.8.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

use Thrift::API::HiveClient::Metastore::Types;
use Thrift::API::HiveClient::Facebook::FB303::FacebookService;

# HELPER FUNCTIONS AND STRUCTURES

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_create_database_args;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_create_database_args->mk_accessors( qw( database ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{database} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{database}) {
      $self->{database} = $vals->{database};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_create_database_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{database} = new Thrift::API::HiveClient::Metastore::Database();
        $xfer += $self->{database}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_database_args');
  if (defined $self->{database}) {
    $xfer += $output->writeFieldBegin('database', TType::STRUCT, 1);
    $xfer += $self->{database}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_create_database_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_create_database_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{o1} = undef;
  $self->{o2} = undef;
  $self->{o3} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
    if (defined $vals->{o3}) {
      $self->{o3} = $vals->{o3};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_create_database_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Thrift::API::HiveClient::Metastore::AlreadyExistsException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Thrift::API::HiveClient::Metastore::InvalidObjectException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o3} = new Thrift::API::HiveClient::Metastore::MetaException();
        $xfer += $self->{o3}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_database_result');
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o3}) {
    $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
    $xfer += $self->{o3}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_database_args;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_database_args->mk_accessors( qw( name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_database_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_database_args');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_database_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_database_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_database_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Thrift::API::HiveClient::Metastore::Database();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Thrift::API::HiveClient::Metastore::NoSuchObjectException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Thrift::API::HiveClient::Metastore::MetaException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_database_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_drop_database_args;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_drop_database_args->mk_accessors( qw( name deleteData ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{deleteData} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{deleteData}) {
      $self->{deleteData} = $vals->{deleteData};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_drop_database_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{deleteData});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_database_args');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{deleteData}) {
    $xfer += $output->writeFieldBegin('deleteData', TType::BOOL, 2);
    $xfer += $output->writeBool($self->{deleteData});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_drop_database_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_drop_database_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{o1} = undef;
  $self->{o2} = undef;
  $self->{o3} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
    if (defined $vals->{o3}) {
      $self->{o3} = $vals->{o3};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_drop_database_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Thrift::API::HiveClient::Metastore::NoSuchObjectException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Thrift::API::HiveClient::Metastore::InvalidOperationException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o3} = new Thrift::API::HiveClient::Metastore::MetaException();
        $xfer += $self->{o3}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_database_result');
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o3}) {
    $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
    $xfer += $self->{o3}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_databases_args;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_databases_args->mk_accessors( qw( pattern ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{pattern} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{pattern}) {
      $self->{pattern} = $vals->{pattern};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_databases_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{pattern});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_databases_args');
  if (defined $self->{pattern}) {
    $xfer += $output->writeFieldBegin('pattern', TType::STRING, 1);
    $xfer += $output->writeString($self->{pattern});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_databases_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_databases_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_databases_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size174 = 0;
          $self->{success} = [];
          my $_etype177 = 0;
          $xfer += $input->readListBegin(\$_etype177, \$_size174);
          for (my $_i178 = 0; $_i178 < $_size174; ++$_i178)
          {
            my $elem179 = undef;
            $xfer += $input->readString(\$elem179);
            push(@{$self->{success}},$elem179);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Thrift::API::HiveClient::Metastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_databases_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter180 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter180);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_all_databases_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_all_databases_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_all_databases_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_all_databases_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_all_databases_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_all_databases_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size181 = 0;
          $self->{success} = [];
          my $_etype184 = 0;
          $xfer += $input->readListBegin(\$_etype184, \$_size181);
          for (my $_i185 = 0; $_i185 < $_size181; ++$_i185)
          {
            my $elem186 = undef;
            $xfer += $input->readString(\$elem186);
            push(@{$self->{success}},$elem186);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Thrift::API::HiveClient::Metastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_all_databases_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter187 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter187);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_alter_database_args;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_alter_database_args->mk_accessors( qw( dbname db ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{dbname} = undef;
  $self->{db} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{dbname}) {
      $self->{dbname} = $vals->{dbname};
    }
    if (defined $vals->{db}) {
      $self->{db} = $vals->{db};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_alter_database_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{dbname});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{db} = new Thrift::API::HiveClient::Metastore::Database();
        $xfer += $self->{db}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_database_args');
  if (defined $self->{dbname}) {
    $xfer += $output->writeFieldBegin('dbname', TType::STRING, 1);
    $xfer += $output->writeString($self->{dbname});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{db}) {
    $xfer += $output->writeFieldBegin('db', TType::STRUCT, 2);
    $xfer += $self->{db}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_alter_database_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_alter_database_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_alter_database_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Thrift::API::HiveClient::Metastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Thrift::API::HiveClient::Metastore::NoSuchObjectException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_database_result');
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_type_args;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_type_args->mk_accessors( qw( name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_type_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_type_args');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_type_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_type_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_type_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Thrift::API::HiveClient::Metastore::Type();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Thrift::API::HiveClient::Metastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Thrift::API::HiveClient::Metastore::NoSuchObjectException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_type_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_create_type_args;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_create_type_args->mk_accessors( qw( type ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{type} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{type}) {
      $self->{type} = $vals->{type};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_create_type_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{type} = new Thrift::API::HiveClient::Metastore::Type();
        $xfer += $self->{type}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_type_args');
  if (defined $self->{type}) {
    $xfer += $output->writeFieldBegin('type', TType::STRUCT, 1);
    $xfer += $self->{type}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_create_type_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_create_type_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  $self->{o3} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
    if (defined $vals->{o3}) {
      $self->{o3} = $vals->{o3};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_create_type_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Thrift::API::HiveClient::Metastore::AlreadyExistsException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Thrift::API::HiveClient::Metastore::InvalidObjectException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o3} = new Thrift::API::HiveClient::Metastore::MetaException();
        $xfer += $self->{o3}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_type_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o3}) {
    $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
    $xfer += $self->{o3}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_drop_type_args;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_drop_type_args->mk_accessors( qw( type ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{type} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{type}) {
      $self->{type} = $vals->{type};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_drop_type_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{type});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_type_args');
  if (defined $self->{type}) {
    $xfer += $output->writeFieldBegin('type', TType::STRING, 1);
    $xfer += $output->writeString($self->{type});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_drop_type_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_drop_type_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_drop_type_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Thrift::API::HiveClient::Metastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Thrift::API::HiveClient::Metastore::NoSuchObjectException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_type_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_type_all_args;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_type_all_args->mk_accessors( qw( name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_type_all_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_type_all_args');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_type_all_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_type_all_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_type_all_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size188 = 0;
          $self->{success} = {};
          my $_ktype189 = 0;
          my $_vtype190 = 0;
          $xfer += $input->readMapBegin(\$_ktype189, \$_vtype190, \$_size188);
          for (my $_i192 = 0; $_i192 < $_size188; ++$_i192)
          {
            my $key193 = '';
            my $val194 = new Thrift::API::HiveClient::Metastore::Type();
            $xfer += $input->readString(\$key193);
            $val194 = new Thrift::API::HiveClient::Metastore::Type();
            $xfer += $val194->read($input);
            $self->{success}->{$key193} = $val194;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Thrift::API::HiveClient::Metastore::MetaException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_type_all_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::MAP, 0);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRUCT, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter195,$viter196) = each %{$self->{success}}) 
        {
          $xfer += $output->writeString($kiter195);
          $xfer += ${viter196}->write($output);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 1);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_fields_args;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_fields_args->mk_accessors( qw( db_name table_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{table_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_fields_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_fields_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_fields_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_fields_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  $self->{o3} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
    if (defined $vals->{o3}) {
      $self->{o3} = $vals->{o3};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_fields_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size197 = 0;
          $self->{success} = [];
          my $_etype200 = 0;
          $xfer += $input->readListBegin(\$_etype200, \$_size197);
          for (my $_i201 = 0; $_i201 < $_size197; ++$_i201)
          {
            my $elem202 = undef;
            $elem202 = new Thrift::API::HiveClient::Metastore::FieldSchema();
            $xfer += $elem202->read($input);
            push(@{$self->{success}},$elem202);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Thrift::API::HiveClient::Metastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Thrift::API::HiveClient::Metastore::UnknownTableException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o3} = new Thrift::API::HiveClient::Metastore::UnknownDBException();
        $xfer += $self->{o3}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_fields_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter203 (@{$self->{success}}) 
        {
          $xfer += ${iter203}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o3}) {
    $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
    $xfer += $self->{o3}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_schema_args;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_schema_args->mk_accessors( qw( db_name table_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{table_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{table_name}) {
      $self->{table_name} = $vals->{table_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_schema_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_schema_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table_name}) {
    $xfer += $output->writeFieldBegin('table_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{table_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_schema_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_schema_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  $self->{o3} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
    if (defined $vals->{o3}) {
      $self->{o3} = $vals->{o3};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_schema_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size204 = 0;
          $self->{success} = [];
          my $_etype207 = 0;
          $xfer += $input->readListBegin(\$_etype207, \$_size204);
          for (my $_i208 = 0; $_i208 < $_size204; ++$_i208)
          {
            my $elem209 = undef;
            $elem209 = new Thrift::API::HiveClient::Metastore::FieldSchema();
            $xfer += $elem209->read($input);
            push(@{$self->{success}},$elem209);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Thrift::API::HiveClient::Metastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Thrift::API::HiveClient::Metastore::UnknownTableException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o3} = new Thrift::API::HiveClient::Metastore::UnknownDBException();
        $xfer += $self->{o3}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_schema_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter210 (@{$self->{success}}) 
        {
          $xfer += ${iter210}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o3}) {
    $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
    $xfer += $self->{o3}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_create_table_args;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_create_table_args->mk_accessors( qw( tbl ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tbl} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tbl}) {
      $self->{tbl} = $vals->{tbl};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_create_table_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{tbl} = new Thrift::API::HiveClient::Metastore::Table();
        $xfer += $self->{tbl}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_table_args');
  if (defined $self->{tbl}) {
    $xfer += $output->writeFieldBegin('tbl', TType::STRUCT, 1);
    $xfer += $self->{tbl}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_create_table_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_create_table_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{o1} = undef;
  $self->{o2} = undef;
  $self->{o3} = undef;
  $self->{o4} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
    if (defined $vals->{o3}) {
      $self->{o3} = $vals->{o3};
    }
    if (defined $vals->{o4}) {
      $self->{o4} = $vals->{o4};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_create_table_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Thrift::API::HiveClient::Metastore::AlreadyExistsException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Thrift::API::HiveClient::Metastore::InvalidObjectException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o3} = new Thrift::API::HiveClient::Metastore::MetaException();
        $xfer += $self->{o3}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o4} = new Thrift::API::HiveClient::Metastore::NoSuchObjectException();
        $xfer += $self->{o4}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_table_result');
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o3}) {
    $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
    $xfer += $self->{o3}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o4}) {
    $xfer += $output->writeFieldBegin('o4', TType::STRUCT, 4);
    $xfer += $self->{o4}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_drop_table_args;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_drop_table_args->mk_accessors( qw( dbname name deleteData ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{dbname} = undef;
  $self->{name} = undef;
  $self->{deleteData} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{dbname}) {
      $self->{dbname} = $vals->{dbname};
    }
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{deleteData}) {
      $self->{deleteData} = $vals->{deleteData};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_drop_table_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{dbname});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{deleteData});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_table_args');
  if (defined $self->{dbname}) {
    $xfer += $output->writeFieldBegin('dbname', TType::STRING, 1);
    $xfer += $output->writeString($self->{dbname});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 2);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{deleteData}) {
    $xfer += $output->writeFieldBegin('deleteData', TType::BOOL, 3);
    $xfer += $output->writeBool($self->{deleteData});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_drop_table_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_drop_table_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{o1} = undef;
  $self->{o3} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o3}) {
      $self->{o3} = $vals->{o3};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_drop_table_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Thrift::API::HiveClient::Metastore::NoSuchObjectException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o3} = new Thrift::API::HiveClient::Metastore::MetaException();
        $xfer += $self->{o3}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_table_result');
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o3}) {
    $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 2);
    $xfer += $self->{o3}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_tables_args;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_tables_args->mk_accessors( qw( db_name pattern ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{pattern} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{pattern}) {
      $self->{pattern} = $vals->{pattern};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_tables_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{pattern});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_tables_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{pattern}) {
    $xfer += $output->writeFieldBegin('pattern', TType::STRING, 2);
    $xfer += $output->writeString($self->{pattern});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_tables_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_tables_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_tables_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size211 = 0;
          $self->{success} = [];
          my $_etype214 = 0;
          $xfer += $input->readListBegin(\$_etype214, \$_size211);
          for (my $_i215 = 0; $_i215 < $_size211; ++$_i215)
          {
            my $elem216 = undef;
            $xfer += $input->readString(\$elem216);
            push(@{$self->{success}},$elem216);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Thrift::API::HiveClient::Metastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_tables_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter217 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter217);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_all_tables_args;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_all_tables_args->mk_accessors( qw( db_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_all_tables_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_all_tables_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_all_tables_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_all_tables_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_all_tables_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size218 = 0;
          $self->{success} = [];
          my $_etype221 = 0;
          $xfer += $input->readListBegin(\$_etype221, \$_size218);
          for (my $_i222 = 0; $_i222 < $_size218; ++$_i222)
          {
            my $elem223 = undef;
            $xfer += $input->readString(\$elem223);
            push(@{$self->{success}},$elem223);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Thrift::API::HiveClient::Metastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_all_tables_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter224 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter224);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_table_args;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_table_args->mk_accessors( qw( dbname tbl_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{dbname} = undef;
  $self->{tbl_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{dbname}) {
      $self->{dbname} = $vals->{dbname};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_table_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{dbname});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_table_args');
  if (defined $self->{dbname}) {
    $xfer += $output->writeFieldBegin('dbname', TType::STRING, 1);
    $xfer += $output->writeString($self->{dbname});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_table_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_table_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_table_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Thrift::API::HiveClient::Metastore::Table();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Thrift::API::HiveClient::Metastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Thrift::API::HiveClient::Metastore::NoSuchObjectException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_table_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_alter_table_args;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_alter_table_args->mk_accessors( qw( dbname tbl_name new_tbl ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{dbname} = undef;
  $self->{tbl_name} = undef;
  $self->{new_tbl} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{dbname}) {
      $self->{dbname} = $vals->{dbname};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{new_tbl}) {
      $self->{new_tbl} = $vals->{new_tbl};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_alter_table_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{dbname});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{new_tbl} = new Thrift::API::HiveClient::Metastore::Table();
        $xfer += $self->{new_tbl}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_table_args');
  if (defined $self->{dbname}) {
    $xfer += $output->writeFieldBegin('dbname', TType::STRING, 1);
    $xfer += $output->writeString($self->{dbname});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{new_tbl}) {
    $xfer += $output->writeFieldBegin('new_tbl', TType::STRUCT, 3);
    $xfer += $self->{new_tbl}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_alter_table_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_alter_table_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_alter_table_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Thrift::API::HiveClient::Metastore::InvalidOperationException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Thrift::API::HiveClient::Metastore::MetaException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_table_result');
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_add_partition_args;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_add_partition_args->mk_accessors( qw( new_part ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{new_part} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{new_part}) {
      $self->{new_part} = $vals->{new_part};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_add_partition_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{new_part} = new Thrift::API::HiveClient::Metastore::Partition();
        $xfer += $self->{new_part}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_partition_args');
  if (defined $self->{new_part}) {
    $xfer += $output->writeFieldBegin('new_part', TType::STRUCT, 1);
    $xfer += $self->{new_part}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_add_partition_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_add_partition_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  $self->{o3} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
    if (defined $vals->{o3}) {
      $self->{o3} = $vals->{o3};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_add_partition_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Thrift::API::HiveClient::Metastore::Partition();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Thrift::API::HiveClient::Metastore::InvalidObjectException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Thrift::API::HiveClient::Metastore::AlreadyExistsException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o3} = new Thrift::API::HiveClient::Metastore::MetaException();
        $xfer += $self->{o3}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_partition_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o3}) {
    $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
    $xfer += $self->{o3}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_append_partition_args;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_append_partition_args->mk_accessors( qw( db_name tbl_name part_vals ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{tbl_name} = undef;
  $self->{part_vals} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{part_vals}) {
      $self->{part_vals} = $vals->{part_vals};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_append_partition_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size225 = 0;
          $self->{part_vals} = [];
          my $_etype228 = 0;
          $xfer += $input->readListBegin(\$_etype228, \$_size225);
          for (my $_i229 = 0; $_i229 < $_size225; ++$_i229)
          {
            my $elem230 = undef;
            $xfer += $input->readString(\$elem230);
            push(@{$self->{part_vals}},$elem230);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_append_partition_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{part_vals}) {
    $xfer += $output->writeFieldBegin('part_vals', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{part_vals}}));
      {
        foreach my $iter231 (@{$self->{part_vals}}) 
        {
          $xfer += $output->writeString($iter231);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_append_partition_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_append_partition_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  $self->{o3} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
    if (defined $vals->{o3}) {
      $self->{o3} = $vals->{o3};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_append_partition_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Thrift::API::HiveClient::Metastore::Partition();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Thrift::API::HiveClient::Metastore::InvalidObjectException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Thrift::API::HiveClient::Metastore::AlreadyExistsException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o3} = new Thrift::API::HiveClient::Metastore::MetaException();
        $xfer += $self->{o3}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_append_partition_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o3}) {
    $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
    $xfer += $self->{o3}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_append_partition_by_name_args;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_append_partition_by_name_args->mk_accessors( qw( db_name tbl_name part_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{tbl_name} = undef;
  $self->{part_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{part_name}) {
      $self->{part_name} = $vals->{part_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_append_partition_by_name_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{part_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_append_partition_by_name_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{part_name}) {
    $xfer += $output->writeFieldBegin('part_name', TType::STRING, 3);
    $xfer += $output->writeString($self->{part_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_append_partition_by_name_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_append_partition_by_name_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  $self->{o3} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
    if (defined $vals->{o3}) {
      $self->{o3} = $vals->{o3};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_append_partition_by_name_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Thrift::API::HiveClient::Metastore::Partition();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Thrift::API::HiveClient::Metastore::InvalidObjectException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Thrift::API::HiveClient::Metastore::AlreadyExistsException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o3} = new Thrift::API::HiveClient::Metastore::MetaException();
        $xfer += $self->{o3}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_append_partition_by_name_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o3}) {
    $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
    $xfer += $self->{o3}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_drop_partition_args;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_drop_partition_args->mk_accessors( qw( db_name tbl_name part_vals deleteData ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{tbl_name} = undef;
  $self->{part_vals} = undef;
  $self->{deleteData} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{part_vals}) {
      $self->{part_vals} = $vals->{part_vals};
    }
    if (defined $vals->{deleteData}) {
      $self->{deleteData} = $vals->{deleteData};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_drop_partition_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size232 = 0;
          $self->{part_vals} = [];
          my $_etype235 = 0;
          $xfer += $input->readListBegin(\$_etype235, \$_size232);
          for (my $_i236 = 0; $_i236 < $_size232; ++$_i236)
          {
            my $elem237 = undef;
            $xfer += $input->readString(\$elem237);
            push(@{$self->{part_vals}},$elem237);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{deleteData});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_partition_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{part_vals}) {
    $xfer += $output->writeFieldBegin('part_vals', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{part_vals}}));
      {
        foreach my $iter238 (@{$self->{part_vals}}) 
        {
          $xfer += $output->writeString($iter238);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{deleteData}) {
    $xfer += $output->writeFieldBegin('deleteData', TType::BOOL, 4);
    $xfer += $output->writeBool($self->{deleteData});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_drop_partition_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_drop_partition_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_drop_partition_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Thrift::API::HiveClient::Metastore::NoSuchObjectException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Thrift::API::HiveClient::Metastore::MetaException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_partition_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_drop_partition_by_name_args;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_drop_partition_by_name_args->mk_accessors( qw( db_name tbl_name part_name deleteData ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{tbl_name} = undef;
  $self->{part_name} = undef;
  $self->{deleteData} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{part_name}) {
      $self->{part_name} = $vals->{part_name};
    }
    if (defined $vals->{deleteData}) {
      $self->{deleteData} = $vals->{deleteData};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_drop_partition_by_name_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{part_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{deleteData});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_partition_by_name_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{part_name}) {
    $xfer += $output->writeFieldBegin('part_name', TType::STRING, 3);
    $xfer += $output->writeString($self->{part_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{deleteData}) {
    $xfer += $output->writeFieldBegin('deleteData', TType::BOOL, 4);
    $xfer += $output->writeBool($self->{deleteData});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_drop_partition_by_name_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_drop_partition_by_name_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_drop_partition_by_name_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Thrift::API::HiveClient::Metastore::NoSuchObjectException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Thrift::API::HiveClient::Metastore::MetaException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_partition_by_name_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partition_args;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partition_args->mk_accessors( qw( db_name tbl_name part_vals ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{tbl_name} = undef;
  $self->{part_vals} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{part_vals}) {
      $self->{part_vals} = $vals->{part_vals};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_partition_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size239 = 0;
          $self->{part_vals} = [];
          my $_etype242 = 0;
          $xfer += $input->readListBegin(\$_etype242, \$_size239);
          for (my $_i243 = 0; $_i243 < $_size239; ++$_i243)
          {
            my $elem244 = undef;
            $xfer += $input->readString(\$elem244);
            push(@{$self->{part_vals}},$elem244);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partition_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{part_vals}) {
    $xfer += $output->writeFieldBegin('part_vals', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{part_vals}}));
      {
        foreach my $iter245 (@{$self->{part_vals}}) 
        {
          $xfer += $output->writeString($iter245);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partition_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partition_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_partition_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Thrift::API::HiveClient::Metastore::Partition();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Thrift::API::HiveClient::Metastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Thrift::API::HiveClient::Metastore::NoSuchObjectException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partition_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partition_with_auth_args;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partition_with_auth_args->mk_accessors( qw( db_name tbl_name part_vals user_name group_names ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{tbl_name} = undef;
  $self->{part_vals} = undef;
  $self->{user_name} = undef;
  $self->{group_names} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{part_vals}) {
      $self->{part_vals} = $vals->{part_vals};
    }
    if (defined $vals->{user_name}) {
      $self->{user_name} = $vals->{user_name};
    }
    if (defined $vals->{group_names}) {
      $self->{group_names} = $vals->{group_names};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_partition_with_auth_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size246 = 0;
          $self->{part_vals} = [];
          my $_etype249 = 0;
          $xfer += $input->readListBegin(\$_etype249, \$_size246);
          for (my $_i250 = 0; $_i250 < $_size246; ++$_i250)
          {
            my $elem251 = undef;
            $xfer += $input->readString(\$elem251);
            push(@{$self->{part_vals}},$elem251);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{user_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size252 = 0;
          $self->{group_names} = [];
          my $_etype255 = 0;
          $xfer += $input->readListBegin(\$_etype255, \$_size252);
          for (my $_i256 = 0; $_i256 < $_size252; ++$_i256)
          {
            my $elem257 = undef;
            $xfer += $input->readString(\$elem257);
            push(@{$self->{group_names}},$elem257);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partition_with_auth_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{part_vals}) {
    $xfer += $output->writeFieldBegin('part_vals', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{part_vals}}));
      {
        foreach my $iter258 (@{$self->{part_vals}}) 
        {
          $xfer += $output->writeString($iter258);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{user_name}) {
    $xfer += $output->writeFieldBegin('user_name', TType::STRING, 4);
    $xfer += $output->writeString($self->{user_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{group_names}) {
    $xfer += $output->writeFieldBegin('group_names', TType::LIST, 5);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{group_names}}));
      {
        foreach my $iter259 (@{$self->{group_names}}) 
        {
          $xfer += $output->writeString($iter259);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partition_with_auth_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partition_with_auth_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_partition_with_auth_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Thrift::API::HiveClient::Metastore::Partition();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Thrift::API::HiveClient::Metastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Thrift::API::HiveClient::Metastore::NoSuchObjectException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partition_with_auth_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partition_by_name_args;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partition_by_name_args->mk_accessors( qw( db_name tbl_name part_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{tbl_name} = undef;
  $self->{part_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{part_name}) {
      $self->{part_name} = $vals->{part_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_partition_by_name_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{part_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partition_by_name_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{part_name}) {
    $xfer += $output->writeFieldBegin('part_name', TType::STRING, 3);
    $xfer += $output->writeString($self->{part_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partition_by_name_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partition_by_name_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_partition_by_name_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Thrift::API::HiveClient::Metastore::Partition();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Thrift::API::HiveClient::Metastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Thrift::API::HiveClient::Metastore::NoSuchObjectException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partition_by_name_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partitions_args;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partitions_args->mk_accessors( qw( db_name tbl_name max_parts ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{tbl_name} = undef;
  $self->{max_parts} = -1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{max_parts}) {
      $self->{max_parts} = $vals->{max_parts};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_partitions_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I16) {
        $xfer += $input->readI16(\$self->{max_parts});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partitions_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{max_parts}) {
    $xfer += $output->writeFieldBegin('max_parts', TType::I16, 3);
    $xfer += $output->writeI16($self->{max_parts});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partitions_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partitions_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_partitions_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size260 = 0;
          $self->{success} = [];
          my $_etype263 = 0;
          $xfer += $input->readListBegin(\$_etype263, \$_size260);
          for (my $_i264 = 0; $_i264 < $_size260; ++$_i264)
          {
            my $elem265 = undef;
            $elem265 = new Thrift::API::HiveClient::Metastore::Partition();
            $xfer += $elem265->read($input);
            push(@{$self->{success}},$elem265);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Thrift::API::HiveClient::Metastore::NoSuchObjectException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Thrift::API::HiveClient::Metastore::MetaException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partitions_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter266 (@{$self->{success}}) 
        {
          $xfer += ${iter266}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partitions_with_auth_args;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partitions_with_auth_args->mk_accessors( qw( db_name tbl_name max_parts user_name group_names ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{tbl_name} = undef;
  $self->{max_parts} = -1;
  $self->{user_name} = undef;
  $self->{group_names} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{max_parts}) {
      $self->{max_parts} = $vals->{max_parts};
    }
    if (defined $vals->{user_name}) {
      $self->{user_name} = $vals->{user_name};
    }
    if (defined $vals->{group_names}) {
      $self->{group_names} = $vals->{group_names};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_partitions_with_auth_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I16) {
        $xfer += $input->readI16(\$self->{max_parts});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{user_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size267 = 0;
          $self->{group_names} = [];
          my $_etype270 = 0;
          $xfer += $input->readListBegin(\$_etype270, \$_size267);
          for (my $_i271 = 0; $_i271 < $_size267; ++$_i271)
          {
            my $elem272 = undef;
            $xfer += $input->readString(\$elem272);
            push(@{$self->{group_names}},$elem272);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partitions_with_auth_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{max_parts}) {
    $xfer += $output->writeFieldBegin('max_parts', TType::I16, 3);
    $xfer += $output->writeI16($self->{max_parts});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{user_name}) {
    $xfer += $output->writeFieldBegin('user_name', TType::STRING, 4);
    $xfer += $output->writeString($self->{user_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{group_names}) {
    $xfer += $output->writeFieldBegin('group_names', TType::LIST, 5);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{group_names}}));
      {
        foreach my $iter273 (@{$self->{group_names}}) 
        {
          $xfer += $output->writeString($iter273);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partitions_with_auth_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partitions_with_auth_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_partitions_with_auth_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size274 = 0;
          $self->{success} = [];
          my $_etype277 = 0;
          $xfer += $input->readListBegin(\$_etype277, \$_size274);
          for (my $_i278 = 0; $_i278 < $_size274; ++$_i278)
          {
            my $elem279 = undef;
            $elem279 = new Thrift::API::HiveClient::Metastore::Partition();
            $xfer += $elem279->read($input);
            push(@{$self->{success}},$elem279);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Thrift::API::HiveClient::Metastore::NoSuchObjectException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Thrift::API::HiveClient::Metastore::MetaException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partitions_with_auth_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter280 (@{$self->{success}}) 
        {
          $xfer += ${iter280}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partition_names_args;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partition_names_args->mk_accessors( qw( db_name tbl_name max_parts ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{tbl_name} = undef;
  $self->{max_parts} = -1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{max_parts}) {
      $self->{max_parts} = $vals->{max_parts};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_partition_names_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I16) {
        $xfer += $input->readI16(\$self->{max_parts});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partition_names_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{max_parts}) {
    $xfer += $output->writeFieldBegin('max_parts', TType::I16, 3);
    $xfer += $output->writeI16($self->{max_parts});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partition_names_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partition_names_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_partition_names_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size281 = 0;
          $self->{success} = [];
          my $_etype284 = 0;
          $xfer += $input->readListBegin(\$_etype284, \$_size281);
          for (my $_i285 = 0; $_i285 < $_size281; ++$_i285)
          {
            my $elem286 = undef;
            $xfer += $input->readString(\$elem286);
            push(@{$self->{success}},$elem286);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Thrift::API::HiveClient::Metastore::MetaException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partition_names_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter287 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter287);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 1);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partitions_ps_args;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partitions_ps_args->mk_accessors( qw( db_name tbl_name part_vals max_parts ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{tbl_name} = undef;
  $self->{part_vals} = undef;
  $self->{max_parts} = -1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{part_vals}) {
      $self->{part_vals} = $vals->{part_vals};
    }
    if (defined $vals->{max_parts}) {
      $self->{max_parts} = $vals->{max_parts};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_partitions_ps_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size288 = 0;
          $self->{part_vals} = [];
          my $_etype291 = 0;
          $xfer += $input->readListBegin(\$_etype291, \$_size288);
          for (my $_i292 = 0; $_i292 < $_size288; ++$_i292)
          {
            my $elem293 = undef;
            $xfer += $input->readString(\$elem293);
            push(@{$self->{part_vals}},$elem293);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I16) {
        $xfer += $input->readI16(\$self->{max_parts});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partitions_ps_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{part_vals}) {
    $xfer += $output->writeFieldBegin('part_vals', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{part_vals}}));
      {
        foreach my $iter294 (@{$self->{part_vals}}) 
        {
          $xfer += $output->writeString($iter294);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{max_parts}) {
    $xfer += $output->writeFieldBegin('max_parts', TType::I16, 4);
    $xfer += $output->writeI16($self->{max_parts});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partitions_ps_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partitions_ps_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_partitions_ps_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size295 = 0;
          $self->{success} = [];
          my $_etype298 = 0;
          $xfer += $input->readListBegin(\$_etype298, \$_size295);
          for (my $_i299 = 0; $_i299 < $_size295; ++$_i299)
          {
            my $elem300 = undef;
            $elem300 = new Thrift::API::HiveClient::Metastore::Partition();
            $xfer += $elem300->read($input);
            push(@{$self->{success}},$elem300);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Thrift::API::HiveClient::Metastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partitions_ps_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter301 (@{$self->{success}}) 
        {
          $xfer += ${iter301}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partitions_ps_with_auth_args;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partitions_ps_with_auth_args->mk_accessors( qw( db_name tbl_name part_vals max_parts user_name group_names ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{tbl_name} = undef;
  $self->{part_vals} = undef;
  $self->{max_parts} = -1;
  $self->{user_name} = undef;
  $self->{group_names} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{part_vals}) {
      $self->{part_vals} = $vals->{part_vals};
    }
    if (defined $vals->{max_parts}) {
      $self->{max_parts} = $vals->{max_parts};
    }
    if (defined $vals->{user_name}) {
      $self->{user_name} = $vals->{user_name};
    }
    if (defined $vals->{group_names}) {
      $self->{group_names} = $vals->{group_names};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_partitions_ps_with_auth_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size302 = 0;
          $self->{part_vals} = [];
          my $_etype305 = 0;
          $xfer += $input->readListBegin(\$_etype305, \$_size302);
          for (my $_i306 = 0; $_i306 < $_size302; ++$_i306)
          {
            my $elem307 = undef;
            $xfer += $input->readString(\$elem307);
            push(@{$self->{part_vals}},$elem307);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I16) {
        $xfer += $input->readI16(\$self->{max_parts});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{user_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size308 = 0;
          $self->{group_names} = [];
          my $_etype311 = 0;
          $xfer += $input->readListBegin(\$_etype311, \$_size308);
          for (my $_i312 = 0; $_i312 < $_size308; ++$_i312)
          {
            my $elem313 = undef;
            $xfer += $input->readString(\$elem313);
            push(@{$self->{group_names}},$elem313);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partitions_ps_with_auth_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{part_vals}) {
    $xfer += $output->writeFieldBegin('part_vals', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{part_vals}}));
      {
        foreach my $iter314 (@{$self->{part_vals}}) 
        {
          $xfer += $output->writeString($iter314);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{max_parts}) {
    $xfer += $output->writeFieldBegin('max_parts', TType::I16, 4);
    $xfer += $output->writeI16($self->{max_parts});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{user_name}) {
    $xfer += $output->writeFieldBegin('user_name', TType::STRING, 5);
    $xfer += $output->writeString($self->{user_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{group_names}) {
    $xfer += $output->writeFieldBegin('group_names', TType::LIST, 6);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{group_names}}));
      {
        foreach my $iter315 (@{$self->{group_names}}) 
        {
          $xfer += $output->writeString($iter315);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partitions_ps_with_auth_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partitions_ps_with_auth_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_partitions_ps_with_auth_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size316 = 0;
          $self->{success} = [];
          my $_etype319 = 0;
          $xfer += $input->readListBegin(\$_etype319, \$_size316);
          for (my $_i320 = 0; $_i320 < $_size316; ++$_i320)
          {
            my $elem321 = undef;
            $elem321 = new Thrift::API::HiveClient::Metastore::Partition();
            $xfer += $elem321->read($input);
            push(@{$self->{success}},$elem321);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Thrift::API::HiveClient::Metastore::NoSuchObjectException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Thrift::API::HiveClient::Metastore::MetaException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partitions_ps_with_auth_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter322 (@{$self->{success}}) 
        {
          $xfer += ${iter322}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partition_names_ps_args;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partition_names_ps_args->mk_accessors( qw( db_name tbl_name part_vals max_parts ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{tbl_name} = undef;
  $self->{part_vals} = undef;
  $self->{max_parts} = -1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{part_vals}) {
      $self->{part_vals} = $vals->{part_vals};
    }
    if (defined $vals->{max_parts}) {
      $self->{max_parts} = $vals->{max_parts};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_partition_names_ps_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size323 = 0;
          $self->{part_vals} = [];
          my $_etype326 = 0;
          $xfer += $input->readListBegin(\$_etype326, \$_size323);
          for (my $_i327 = 0; $_i327 < $_size323; ++$_i327)
          {
            my $elem328 = undef;
            $xfer += $input->readString(\$elem328);
            push(@{$self->{part_vals}},$elem328);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I16) {
        $xfer += $input->readI16(\$self->{max_parts});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partition_names_ps_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{part_vals}) {
    $xfer += $output->writeFieldBegin('part_vals', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{part_vals}}));
      {
        foreach my $iter329 (@{$self->{part_vals}}) 
        {
          $xfer += $output->writeString($iter329);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{max_parts}) {
    $xfer += $output->writeFieldBegin('max_parts', TType::I16, 4);
    $xfer += $output->writeI16($self->{max_parts});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partition_names_ps_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partition_names_ps_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_partition_names_ps_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size330 = 0;
          $self->{success} = [];
          my $_etype333 = 0;
          $xfer += $input->readListBegin(\$_etype333, \$_size330);
          for (my $_i334 = 0; $_i334 < $_size330; ++$_i334)
          {
            my $elem335 = undef;
            $xfer += $input->readString(\$elem335);
            push(@{$self->{success}},$elem335);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Thrift::API::HiveClient::Metastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partition_names_ps_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter336 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter336);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partitions_by_filter_args;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partitions_by_filter_args->mk_accessors( qw( db_name tbl_name filter max_parts ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{tbl_name} = undef;
  $self->{filter} = undef;
  $self->{max_parts} = -1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{filter}) {
      $self->{filter} = $vals->{filter};
    }
    if (defined $vals->{max_parts}) {
      $self->{max_parts} = $vals->{max_parts};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_partitions_by_filter_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{filter});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I16) {
        $xfer += $input->readI16(\$self->{max_parts});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partitions_by_filter_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{filter}) {
    $xfer += $output->writeFieldBegin('filter', TType::STRING, 3);
    $xfer += $output->writeString($self->{filter});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{max_parts}) {
    $xfer += $output->writeFieldBegin('max_parts', TType::I16, 4);
    $xfer += $output->writeI16($self->{max_parts});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partitions_by_filter_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partitions_by_filter_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_partitions_by_filter_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size337 = 0;
          $self->{success} = [];
          my $_etype340 = 0;
          $xfer += $input->readListBegin(\$_etype340, \$_size337);
          for (my $_i341 = 0; $_i341 < $_size337; ++$_i341)
          {
            my $elem342 = undef;
            $elem342 = new Thrift::API::HiveClient::Metastore::Partition();
            $xfer += $elem342->read($input);
            push(@{$self->{success}},$elem342);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Thrift::API::HiveClient::Metastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Thrift::API::HiveClient::Metastore::NoSuchObjectException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_partitions_by_filter_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter343 (@{$self->{success}}) 
        {
          $xfer += ${iter343}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_alter_partition_args;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_alter_partition_args->mk_accessors( qw( db_name tbl_name new_part ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{tbl_name} = undef;
  $self->{new_part} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{new_part}) {
      $self->{new_part} = $vals->{new_part};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_alter_partition_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{new_part} = new Thrift::API::HiveClient::Metastore::Partition();
        $xfer += $self->{new_part}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_partition_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{new_part}) {
    $xfer += $output->writeFieldBegin('new_part', TType::STRUCT, 3);
    $xfer += $self->{new_part}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_alter_partition_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_alter_partition_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_alter_partition_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Thrift::API::HiveClient::Metastore::InvalidOperationException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Thrift::API::HiveClient::Metastore::MetaException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_partition_result');
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_config_value_args;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_config_value_args->mk_accessors( qw( name defaultValue ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{defaultValue} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{defaultValue}) {
      $self->{defaultValue} = $vals->{defaultValue};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_config_value_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{defaultValue});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_config_value_args');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{defaultValue}) {
    $xfer += $output->writeFieldBegin('defaultValue', TType::STRING, 2);
    $xfer += $output->writeString($self->{defaultValue});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_config_value_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_config_value_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_config_value_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Thrift::API::HiveClient::Metastore::ConfigValSecurityException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_config_value_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_partition_name_to_vals_args;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_partition_name_to_vals_args->mk_accessors( qw( part_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{part_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{part_name}) {
      $self->{part_name} = $vals->{part_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_partition_name_to_vals_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{part_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_partition_name_to_vals_args');
  if (defined $self->{part_name}) {
    $xfer += $output->writeFieldBegin('part_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{part_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_partition_name_to_vals_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_partition_name_to_vals_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_partition_name_to_vals_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size344 = 0;
          $self->{success} = [];
          my $_etype347 = 0;
          $xfer += $input->readListBegin(\$_etype347, \$_size344);
          for (my $_i348 = 0; $_i348 < $_size344; ++$_i348)
          {
            my $elem349 = undef;
            $xfer += $input->readString(\$elem349);
            push(@{$self->{success}},$elem349);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Thrift::API::HiveClient::Metastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_partition_name_to_vals_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter350 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter350);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_partition_name_to_spec_args;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_partition_name_to_spec_args->mk_accessors( qw( part_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{part_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{part_name}) {
      $self->{part_name} = $vals->{part_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_partition_name_to_spec_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{part_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_partition_name_to_spec_args');
  if (defined $self->{part_name}) {
    $xfer += $output->writeFieldBegin('part_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{part_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_partition_name_to_spec_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_partition_name_to_spec_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_partition_name_to_spec_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size351 = 0;
          $self->{success} = {};
          my $_ktype352 = 0;
          my $_vtype353 = 0;
          $xfer += $input->readMapBegin(\$_ktype352, \$_vtype353, \$_size351);
          for (my $_i355 = 0; $_i355 < $_size351; ++$_i355)
          {
            my $key356 = '';
            my $val357 = '';
            $xfer += $input->readString(\$key356);
            $xfer += $input->readString(\$val357);
            $self->{success}->{$key356} = $val357;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Thrift::API::HiveClient::Metastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_partition_name_to_spec_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::MAP, 0);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter358,$viter359) = each %{$self->{success}}) 
        {
          $xfer += $output->writeString($kiter358);
          $xfer += $output->writeString($viter359);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_add_index_args;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_add_index_args->mk_accessors( qw( new_index index_table ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{new_index} = undef;
  $self->{index_table} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{new_index}) {
      $self->{new_index} = $vals->{new_index};
    }
    if (defined $vals->{index_table}) {
      $self->{index_table} = $vals->{index_table};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_add_index_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{new_index} = new Thrift::API::HiveClient::Metastore::Index();
        $xfer += $self->{new_index}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{index_table} = new Thrift::API::HiveClient::Metastore::Table();
        $xfer += $self->{index_table}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_index_args');
  if (defined $self->{new_index}) {
    $xfer += $output->writeFieldBegin('new_index', TType::STRUCT, 1);
    $xfer += $self->{new_index}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{index_table}) {
    $xfer += $output->writeFieldBegin('index_table', TType::STRUCT, 2);
    $xfer += $self->{index_table}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_add_index_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_add_index_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  $self->{o3} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
    if (defined $vals->{o3}) {
      $self->{o3} = $vals->{o3};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_add_index_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Thrift::API::HiveClient::Metastore::Index();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Thrift::API::HiveClient::Metastore::InvalidObjectException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Thrift::API::HiveClient::Metastore::AlreadyExistsException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o3} = new Thrift::API::HiveClient::Metastore::MetaException();
        $xfer += $self->{o3}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_add_index_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o3}) {
    $xfer += $output->writeFieldBegin('o3', TType::STRUCT, 3);
    $xfer += $self->{o3}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_alter_index_args;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_alter_index_args->mk_accessors( qw( dbname base_tbl_name idx_name new_idx ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{dbname} = undef;
  $self->{base_tbl_name} = undef;
  $self->{idx_name} = undef;
  $self->{new_idx} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{dbname}) {
      $self->{dbname} = $vals->{dbname};
    }
    if (defined $vals->{base_tbl_name}) {
      $self->{base_tbl_name} = $vals->{base_tbl_name};
    }
    if (defined $vals->{idx_name}) {
      $self->{idx_name} = $vals->{idx_name};
    }
    if (defined $vals->{new_idx}) {
      $self->{new_idx} = $vals->{new_idx};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_alter_index_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{dbname});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{base_tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{idx_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{new_idx} = new Thrift::API::HiveClient::Metastore::Index();
        $xfer += $self->{new_idx}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_index_args');
  if (defined $self->{dbname}) {
    $xfer += $output->writeFieldBegin('dbname', TType::STRING, 1);
    $xfer += $output->writeString($self->{dbname});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{base_tbl_name}) {
    $xfer += $output->writeFieldBegin('base_tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{base_tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{idx_name}) {
    $xfer += $output->writeFieldBegin('idx_name', TType::STRING, 3);
    $xfer += $output->writeString($self->{idx_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{new_idx}) {
    $xfer += $output->writeFieldBegin('new_idx', TType::STRUCT, 4);
    $xfer += $self->{new_idx}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_alter_index_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_alter_index_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_alter_index_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Thrift::API::HiveClient::Metastore::InvalidOperationException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Thrift::API::HiveClient::Metastore::MetaException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_alter_index_result');
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_drop_index_by_name_args;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_drop_index_by_name_args->mk_accessors( qw( db_name tbl_name index_name deleteData ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{tbl_name} = undef;
  $self->{index_name} = undef;
  $self->{deleteData} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{index_name}) {
      $self->{index_name} = $vals->{index_name};
    }
    if (defined $vals->{deleteData}) {
      $self->{deleteData} = $vals->{deleteData};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_drop_index_by_name_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{index_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{deleteData});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_index_by_name_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{index_name}) {
    $xfer += $output->writeFieldBegin('index_name', TType::STRING, 3);
    $xfer += $output->writeString($self->{index_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{deleteData}) {
    $xfer += $output->writeFieldBegin('deleteData', TType::BOOL, 4);
    $xfer += $output->writeBool($self->{deleteData});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_drop_index_by_name_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_drop_index_by_name_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_drop_index_by_name_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Thrift::API::HiveClient::Metastore::NoSuchObjectException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Thrift::API::HiveClient::Metastore::MetaException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_index_by_name_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_index_by_name_args;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_index_by_name_args->mk_accessors( qw( db_name tbl_name index_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{tbl_name} = undef;
  $self->{index_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{index_name}) {
      $self->{index_name} = $vals->{index_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_index_by_name_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{index_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_index_by_name_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{index_name}) {
    $xfer += $output->writeFieldBegin('index_name', TType::STRING, 3);
    $xfer += $output->writeString($self->{index_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_index_by_name_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_index_by_name_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_index_by_name_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Thrift::API::HiveClient::Metastore::Index();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Thrift::API::HiveClient::Metastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Thrift::API::HiveClient::Metastore::NoSuchObjectException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_index_by_name_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_indexes_args;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_indexes_args->mk_accessors( qw( db_name tbl_name max_indexes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{tbl_name} = undef;
  $self->{max_indexes} = -1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{max_indexes}) {
      $self->{max_indexes} = $vals->{max_indexes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_indexes_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I16) {
        $xfer += $input->readI16(\$self->{max_indexes});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_indexes_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{max_indexes}) {
    $xfer += $output->writeFieldBegin('max_indexes', TType::I16, 3);
    $xfer += $output->writeI16($self->{max_indexes});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_indexes_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_indexes_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_indexes_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size360 = 0;
          $self->{success} = [];
          my $_etype363 = 0;
          $xfer += $input->readListBegin(\$_etype363, \$_size360);
          for (my $_i364 = 0; $_i364 < $_size360; ++$_i364)
          {
            my $elem365 = undef;
            $elem365 = new Thrift::API::HiveClient::Metastore::Index();
            $xfer += $elem365->read($input);
            push(@{$self->{success}},$elem365);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Thrift::API::HiveClient::Metastore::NoSuchObjectException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Thrift::API::HiveClient::Metastore::MetaException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_indexes_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter366 (@{$self->{success}}) 
        {
          $xfer += ${iter366}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 2);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_index_names_args;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_index_names_args->mk_accessors( qw( db_name tbl_name max_indexes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{db_name} = undef;
  $self->{tbl_name} = undef;
  $self->{max_indexes} = -1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{db_name}) {
      $self->{db_name} = $vals->{db_name};
    }
    if (defined $vals->{tbl_name}) {
      $self->{tbl_name} = $vals->{tbl_name};
    }
    if (defined $vals->{max_indexes}) {
      $self->{max_indexes} = $vals->{max_indexes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_index_names_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{db_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tbl_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I16) {
        $xfer += $input->readI16(\$self->{max_indexes});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_index_names_args');
  if (defined $self->{db_name}) {
    $xfer += $output->writeFieldBegin('db_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{db_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tbl_name}) {
    $xfer += $output->writeFieldBegin('tbl_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{tbl_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{max_indexes}) {
    $xfer += $output->writeFieldBegin('max_indexes', TType::I16, 3);
    $xfer += $output->writeI16($self->{max_indexes});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_index_names_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_index_names_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o2} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o2}) {
      $self->{o2} = $vals->{o2};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_index_names_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size367 = 0;
          $self->{success} = [];
          my $_etype370 = 0;
          $xfer += $input->readListBegin(\$_etype370, \$_size367);
          for (my $_i371 = 0; $_i371 < $_size367; ++$_i371)
          {
            my $elem372 = undef;
            $xfer += $input->readString(\$elem372);
            push(@{$self->{success}},$elem372);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o2} = new Thrift::API::HiveClient::Metastore::MetaException();
        $xfer += $self->{o2}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_index_names_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter373 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter373);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o2}) {
    $xfer += $output->writeFieldBegin('o2', TType::STRUCT, 1);
    $xfer += $self->{o2}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_create_role_args;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_create_role_args->mk_accessors( qw( role ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{role} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{role}) {
      $self->{role} = $vals->{role};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_create_role_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{role} = new Thrift::API::HiveClient::Metastore::Role();
        $xfer += $self->{role}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_role_args');
  if (defined $self->{role}) {
    $xfer += $output->writeFieldBegin('role', TType::STRUCT, 1);
    $xfer += $self->{role}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_create_role_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_create_role_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_create_role_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Thrift::API::HiveClient::Metastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_create_role_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_drop_role_args;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_drop_role_args->mk_accessors( qw( role_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{role_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{role_name}) {
      $self->{role_name} = $vals->{role_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_drop_role_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{role_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_role_args');
  if (defined $self->{role_name}) {
    $xfer += $output->writeFieldBegin('role_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{role_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_drop_role_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_drop_role_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_drop_role_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Thrift::API::HiveClient::Metastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_drop_role_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_role_names_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_role_names_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_role_names_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_role_names_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_role_names_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_role_names_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size374 = 0;
          $self->{success} = [];
          my $_etype377 = 0;
          $xfer += $input->readListBegin(\$_etype377, \$_size374);
          for (my $_i378 = 0; $_i378 < $_size374; ++$_i378)
          {
            my $elem379 = undef;
            $xfer += $input->readString(\$elem379);
            push(@{$self->{success}},$elem379);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Thrift::API::HiveClient::Metastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_role_names_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter380 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter380);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_grant_role_args;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_grant_role_args->mk_accessors( qw( role_name principal_name principal_type grantor grantorType grant_option ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{role_name} = undef;
  $self->{principal_name} = undef;
  $self->{principal_type} = undef;
  $self->{grantor} = undef;
  $self->{grantorType} = undef;
  $self->{grant_option} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{role_name}) {
      $self->{role_name} = $vals->{role_name};
    }
    if (defined $vals->{principal_name}) {
      $self->{principal_name} = $vals->{principal_name};
    }
    if (defined $vals->{principal_type}) {
      $self->{principal_type} = $vals->{principal_type};
    }
    if (defined $vals->{grantor}) {
      $self->{grantor} = $vals->{grantor};
    }
    if (defined $vals->{grantorType}) {
      $self->{grantorType} = $vals->{grantorType};
    }
    if (defined $vals->{grant_option}) {
      $self->{grant_option} = $vals->{grant_option};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_grant_role_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{role_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{principal_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{principal_type});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{grantor});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{grantorType});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{grant_option});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_grant_role_args');
  if (defined $self->{role_name}) {
    $xfer += $output->writeFieldBegin('role_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{role_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{principal_name}) {
    $xfer += $output->writeFieldBegin('principal_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{principal_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{principal_type}) {
    $xfer += $output->writeFieldBegin('principal_type', TType::I32, 3);
    $xfer += $output->writeI32($self->{principal_type});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{grantor}) {
    $xfer += $output->writeFieldBegin('grantor', TType::STRING, 4);
    $xfer += $output->writeString($self->{grantor});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{grantorType}) {
    $xfer += $output->writeFieldBegin('grantorType', TType::I32, 5);
    $xfer += $output->writeI32($self->{grantorType});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{grant_option}) {
    $xfer += $output->writeFieldBegin('grant_option', TType::BOOL, 6);
    $xfer += $output->writeBool($self->{grant_option});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_grant_role_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_grant_role_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_grant_role_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Thrift::API::HiveClient::Metastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_grant_role_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_revoke_role_args;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_revoke_role_args->mk_accessors( qw( role_name principal_name principal_type ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{role_name} = undef;
  $self->{principal_name} = undef;
  $self->{principal_type} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{role_name}) {
      $self->{role_name} = $vals->{role_name};
    }
    if (defined $vals->{principal_name}) {
      $self->{principal_name} = $vals->{principal_name};
    }
    if (defined $vals->{principal_type}) {
      $self->{principal_type} = $vals->{principal_type};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_revoke_role_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{role_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{principal_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{principal_type});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_revoke_role_args');
  if (defined $self->{role_name}) {
    $xfer += $output->writeFieldBegin('role_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{role_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{principal_name}) {
    $xfer += $output->writeFieldBegin('principal_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{principal_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{principal_type}) {
    $xfer += $output->writeFieldBegin('principal_type', TType::I32, 3);
    $xfer += $output->writeI32($self->{principal_type});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_revoke_role_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_revoke_role_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_revoke_role_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Thrift::API::HiveClient::Metastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_revoke_role_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_list_roles_args;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_list_roles_args->mk_accessors( qw( principal_name principal_type ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{principal_name} = undef;
  $self->{principal_type} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{principal_name}) {
      $self->{principal_name} = $vals->{principal_name};
    }
    if (defined $vals->{principal_type}) {
      $self->{principal_type} = $vals->{principal_type};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_list_roles_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{principal_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{principal_type});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_list_roles_args');
  if (defined $self->{principal_name}) {
    $xfer += $output->writeFieldBegin('principal_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{principal_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{principal_type}) {
    $xfer += $output->writeFieldBegin('principal_type', TType::I32, 2);
    $xfer += $output->writeI32($self->{principal_type});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_list_roles_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_list_roles_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_list_roles_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size381 = 0;
          $self->{success} = [];
          my $_etype384 = 0;
          $xfer += $input->readListBegin(\$_etype384, \$_size381);
          for (my $_i385 = 0; $_i385 < $_size381; ++$_i385)
          {
            my $elem386 = undef;
            $elem386 = new Thrift::API::HiveClient::Metastore::Role();
            $xfer += $elem386->read($input);
            push(@{$self->{success}},$elem386);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Thrift::API::HiveClient::Metastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_list_roles_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter387 (@{$self->{success}}) 
        {
          $xfer += ${iter387}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_privilege_set_args;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_privilege_set_args->mk_accessors( qw( hiveObject user_name group_names ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{hiveObject} = undef;
  $self->{user_name} = undef;
  $self->{group_names} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{hiveObject}) {
      $self->{hiveObject} = $vals->{hiveObject};
    }
    if (defined $vals->{user_name}) {
      $self->{user_name} = $vals->{user_name};
    }
    if (defined $vals->{group_names}) {
      $self->{group_names} = $vals->{group_names};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_privilege_set_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{hiveObject} = new Thrift::API::HiveClient::Metastore::HiveObjectRef();
        $xfer += $self->{hiveObject}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{user_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size388 = 0;
          $self->{group_names} = [];
          my $_etype391 = 0;
          $xfer += $input->readListBegin(\$_etype391, \$_size388);
          for (my $_i392 = 0; $_i392 < $_size388; ++$_i392)
          {
            my $elem393 = undef;
            $xfer += $input->readString(\$elem393);
            push(@{$self->{group_names}},$elem393);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_privilege_set_args');
  if (defined $self->{hiveObject}) {
    $xfer += $output->writeFieldBegin('hiveObject', TType::STRUCT, 1);
    $xfer += $self->{hiveObject}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{user_name}) {
    $xfer += $output->writeFieldBegin('user_name', TType::STRING, 2);
    $xfer += $output->writeString($self->{user_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{group_names}) {
    $xfer += $output->writeFieldBegin('group_names', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{group_names}}));
      {
        foreach my $iter394 (@{$self->{group_names}}) 
        {
          $xfer += $output->writeString($iter394);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_privilege_set_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_privilege_set_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_privilege_set_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Thrift::API::HiveClient::Metastore::PrincipalPrivilegeSet();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Thrift::API::HiveClient::Metastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_privilege_set_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_list_privileges_args;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_list_privileges_args->mk_accessors( qw( principal_name principal_type hiveObject ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{principal_name} = undef;
  $self->{principal_type} = undef;
  $self->{hiveObject} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{principal_name}) {
      $self->{principal_name} = $vals->{principal_name};
    }
    if (defined $vals->{principal_type}) {
      $self->{principal_type} = $vals->{principal_type};
    }
    if (defined $vals->{hiveObject}) {
      $self->{hiveObject} = $vals->{hiveObject};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_list_privileges_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{principal_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{principal_type});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{hiveObject} = new Thrift::API::HiveClient::Metastore::HiveObjectRef();
        $xfer += $self->{hiveObject}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_list_privileges_args');
  if (defined $self->{principal_name}) {
    $xfer += $output->writeFieldBegin('principal_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{principal_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{principal_type}) {
    $xfer += $output->writeFieldBegin('principal_type', TType::I32, 2);
    $xfer += $output->writeI32($self->{principal_type});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{hiveObject}) {
    $xfer += $output->writeFieldBegin('hiveObject', TType::STRUCT, 3);
    $xfer += $self->{hiveObject}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_list_privileges_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_list_privileges_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_list_privileges_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size395 = 0;
          $self->{success} = [];
          my $_etype398 = 0;
          $xfer += $input->readListBegin(\$_etype398, \$_size395);
          for (my $_i399 = 0; $_i399 < $_size395; ++$_i399)
          {
            my $elem400 = undef;
            $elem400 = new Thrift::API::HiveClient::Metastore::HiveObjectPrivilege();
            $xfer += $elem400->read($input);
            push(@{$self->{success}},$elem400);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Thrift::API::HiveClient::Metastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_list_privileges_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter401 (@{$self->{success}}) 
        {
          $xfer += ${iter401}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_grant_privileges_args;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_grant_privileges_args->mk_accessors( qw( privileges ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{privileges} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{privileges}) {
      $self->{privileges} = $vals->{privileges};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_grant_privileges_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{privileges} = new Thrift::API::HiveClient::Metastore::PrivilegeBag();
        $xfer += $self->{privileges}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_grant_privileges_args');
  if (defined $self->{privileges}) {
    $xfer += $output->writeFieldBegin('privileges', TType::STRUCT, 1);
    $xfer += $self->{privileges}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_grant_privileges_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_grant_privileges_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_grant_privileges_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Thrift::API::HiveClient::Metastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_grant_privileges_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_revoke_privileges_args;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_revoke_privileges_args->mk_accessors( qw( privileges ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{privileges} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{privileges}) {
      $self->{privileges} = $vals->{privileges};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_revoke_privileges_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{privileges} = new Thrift::API::HiveClient::Metastore::PrivilegeBag();
        $xfer += $self->{privileges}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_revoke_privileges_args');
  if (defined $self->{privileges}) {
    $xfer += $output->writeFieldBegin('privileges', TType::STRUCT, 1);
    $xfer += $self->{privileges}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_revoke_privileges_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_revoke_privileges_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_revoke_privileges_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Thrift::API::HiveClient::Metastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_revoke_privileges_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_delegation_token_args;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_delegation_token_args->mk_accessors( qw( renewer_kerberos_principal_name ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{renewer_kerberos_principal_name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{renewer_kerberos_principal_name}) {
      $self->{renewer_kerberos_principal_name} = $vals->{renewer_kerberos_principal_name};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_delegation_token_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{renewer_kerberos_principal_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_delegation_token_args');
  if (defined $self->{renewer_kerberos_principal_name}) {
    $xfer += $output->writeFieldBegin('renewer_kerberos_principal_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{renewer_kerberos_principal_name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_delegation_token_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_delegation_token_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_delegation_token_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Thrift::API::HiveClient::Metastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_delegation_token_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_delegation_token_with_signature_args;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_delegation_token_with_signature_args->mk_accessors( qw( renewer_kerberos_principal_name token_signature ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{renewer_kerberos_principal_name} = undef;
  $self->{token_signature} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{renewer_kerberos_principal_name}) {
      $self->{renewer_kerberos_principal_name} = $vals->{renewer_kerberos_principal_name};
    }
    if (defined $vals->{token_signature}) {
      $self->{token_signature} = $vals->{token_signature};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_delegation_token_with_signature_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{renewer_kerberos_principal_name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{token_signature});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_delegation_token_with_signature_args');
  if (defined $self->{renewer_kerberos_principal_name}) {
    $xfer += $output->writeFieldBegin('renewer_kerberos_principal_name', TType::STRING, 1);
    $xfer += $output->writeString($self->{renewer_kerberos_principal_name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{token_signature}) {
    $xfer += $output->writeFieldBegin('token_signature', TType::STRING, 2);
    $xfer += $output->writeString($self->{token_signature});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_delegation_token_with_signature_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_delegation_token_with_signature_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_get_delegation_token_with_signature_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Thrift::API::HiveClient::Metastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_get_delegation_token_with_signature_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_renew_delegation_token_args;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_renew_delegation_token_args->mk_accessors( qw( token_str_form ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{token_str_form} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{token_str_form}) {
      $self->{token_str_form} = $vals->{token_str_form};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_renew_delegation_token_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{token_str_form});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_renew_delegation_token_args');
  if (defined $self->{token_str_form}) {
    $xfer += $output->writeFieldBegin('token_str_form', TType::STRING, 1);
    $xfer += $output->writeString($self->{token_str_form});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_renew_delegation_token_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_renew_delegation_token_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{o1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_renew_delegation_token_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Thrift::API::HiveClient::Metastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_renew_delegation_token_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_cancel_delegation_token_args;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_cancel_delegation_token_args->mk_accessors( qw( token_str_form ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{token_str_form} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{token_str_form}) {
      $self->{token_str_form} = $vals->{token_str_form};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_cancel_delegation_token_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{token_str_form});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_cancel_delegation_token_args');
  if (defined $self->{token_str_form}) {
    $xfer += $output->writeFieldBegin('token_str_form', TType::STRING, 1);
    $xfer += $output->writeString($self->{token_str_form});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_cancel_delegation_token_result;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_cancel_delegation_token_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{o1} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{o1}) {
      $self->{o1} = $vals->{o1};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ThriftHiveMetastore_cancel_delegation_token_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{o1} = new Thrift::API::HiveClient::Metastore::MetaException();
        $xfer += $self->{o1}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ThriftHiveMetastore_cancel_delegation_token_result');
  if (defined $self->{o1}) {
    $xfer += $output->writeFieldBegin('o1', TType::STRUCT, 1);
    $xfer += $self->{o1}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastoreIf;

use strict;
use base qw(Thrift::API::HiveClient::Facebook::FB303::FacebookServiceIf);

sub create_database{
  my $self = shift;
  my $database = shift;

  die 'implement interface';
}

sub get_database{
  my $self = shift;
  my $name = shift;

  die 'implement interface';
}

sub drop_database{
  my $self = shift;
  my $name = shift;
  my $deleteData = shift;

  die 'implement interface';
}

sub get_databases{
  my $self = shift;
  my $pattern = shift;

  die 'implement interface';
}

sub get_all_databases{
  my $self = shift;

  die 'implement interface';
}

sub alter_database{
  my $self = shift;
  my $dbname = shift;
  my $db = shift;

  die 'implement interface';
}

sub get_type{
  my $self = shift;
  my $name = shift;

  die 'implement interface';
}

sub create_type{
  my $self = shift;
  my $type = shift;

  die 'implement interface';
}

sub drop_type{
  my $self = shift;
  my $type = shift;

  die 'implement interface';
}

sub get_type_all{
  my $self = shift;
  my $name = shift;

  die 'implement interface';
}

sub get_fields{
  my $self = shift;
  my $db_name = shift;
  my $table_name = shift;

  die 'implement interface';
}

sub get_schema{
  my $self = shift;
  my $db_name = shift;
  my $table_name = shift;

  die 'implement interface';
}

sub create_table{
  my $self = shift;
  my $tbl = shift;

  die 'implement interface';
}

sub drop_table{
  my $self = shift;
  my $dbname = shift;
  my $name = shift;
  my $deleteData = shift;

  die 'implement interface';
}

sub get_tables{
  my $self = shift;
  my $db_name = shift;
  my $pattern = shift;

  die 'implement interface';
}

sub get_all_tables{
  my $self = shift;
  my $db_name = shift;

  die 'implement interface';
}

sub get_table{
  my $self = shift;
  my $dbname = shift;
  my $tbl_name = shift;

  die 'implement interface';
}

sub alter_table{
  my $self = shift;
  my $dbname = shift;
  my $tbl_name = shift;
  my $new_tbl = shift;

  die 'implement interface';
}

sub add_partition{
  my $self = shift;
  my $new_part = shift;

  die 'implement interface';
}

sub append_partition{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;

  die 'implement interface';
}

sub append_partition_by_name{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_name = shift;

  die 'implement interface';
}

sub drop_partition{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;
  my $deleteData = shift;

  die 'implement interface';
}

sub drop_partition_by_name{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_name = shift;
  my $deleteData = shift;

  die 'implement interface';
}

sub get_partition{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;

  die 'implement interface';
}

sub get_partition_with_auth{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;
  my $user_name = shift;
  my $group_names = shift;

  die 'implement interface';
}

sub get_partition_by_name{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_name = shift;

  die 'implement interface';
}

sub get_partitions{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $max_parts = shift;

  die 'implement interface';
}

sub get_partitions_with_auth{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $max_parts = shift;
  my $user_name = shift;
  my $group_names = shift;

  die 'implement interface';
}

sub get_partition_names{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $max_parts = shift;

  die 'implement interface';
}

sub get_partitions_ps{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;
  my $max_parts = shift;

  die 'implement interface';
}

sub get_partitions_ps_with_auth{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;
  my $max_parts = shift;
  my $user_name = shift;
  my $group_names = shift;

  die 'implement interface';
}

sub get_partition_names_ps{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;
  my $max_parts = shift;

  die 'implement interface';
}

sub get_partitions_by_filter{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $filter = shift;
  my $max_parts = shift;

  die 'implement interface';
}

sub alter_partition{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $new_part = shift;

  die 'implement interface';
}

sub get_config_value{
  my $self = shift;
  my $name = shift;
  my $defaultValue = shift;

  die 'implement interface';
}

sub partition_name_to_vals{
  my $self = shift;
  my $part_name = shift;

  die 'implement interface';
}

sub partition_name_to_spec{
  my $self = shift;
  my $part_name = shift;

  die 'implement interface';
}

sub add_index{
  my $self = shift;
  my $new_index = shift;
  my $index_table = shift;

  die 'implement interface';
}

sub alter_index{
  my $self = shift;
  my $dbname = shift;
  my $base_tbl_name = shift;
  my $idx_name = shift;
  my $new_idx = shift;

  die 'implement interface';
}

sub drop_index_by_name{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $index_name = shift;
  my $deleteData = shift;

  die 'implement interface';
}

sub get_index_by_name{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $index_name = shift;

  die 'implement interface';
}

sub get_indexes{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $max_indexes = shift;

  die 'implement interface';
}

sub get_index_names{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $max_indexes = shift;

  die 'implement interface';
}

sub create_role{
  my $self = shift;
  my $role = shift;

  die 'implement interface';
}

sub drop_role{
  my $self = shift;
  my $role_name = shift;

  die 'implement interface';
}

sub get_role_names{
  my $self = shift;

  die 'implement interface';
}

sub grant_role{
  my $self = shift;
  my $role_name = shift;
  my $principal_name = shift;
  my $principal_type = shift;
  my $grantor = shift;
  my $grantorType = shift;
  my $grant_option = shift;

  die 'implement interface';
}

sub revoke_role{
  my $self = shift;
  my $role_name = shift;
  my $principal_name = shift;
  my $principal_type = shift;

  die 'implement interface';
}

sub list_roles{
  my $self = shift;
  my $principal_name = shift;
  my $principal_type = shift;

  die 'implement interface';
}

sub get_privilege_set{
  my $self = shift;
  my $hiveObject = shift;
  my $user_name = shift;
  my $group_names = shift;

  die 'implement interface';
}

sub list_privileges{
  my $self = shift;
  my $principal_name = shift;
  my $principal_type = shift;
  my $hiveObject = shift;

  die 'implement interface';
}

sub grant_privileges{
  my $self = shift;
  my $privileges = shift;

  die 'implement interface';
}

sub revoke_privileges{
  my $self = shift;
  my $privileges = shift;

  die 'implement interface';
}

sub get_delegation_token{
  my $self = shift;
  my $renewer_kerberos_principal_name = shift;

  die 'implement interface';
}

sub get_delegation_token_with_signature{
  my $self = shift;
  my $renewer_kerberos_principal_name = shift;
  my $token_signature = shift;

  die 'implement interface';
}

sub renew_delegation_token{
  my $self = shift;
  my $token_str_form = shift;

  die 'implement interface';
}

sub cancel_delegation_token{
  my $self = shift;
  my $token_str_form = shift;

  die 'implement interface';
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastoreRest;

use strict;
use base qw(Thrift::API::HiveClient::Facebook::FB303::FacebookServiceRest);

sub create_database{
  my ($self, $request) = @_;

  my $database = ($request->{'database'}) ? $request->{'database'} : undef;
  return $self->{impl}->create_database($database);
}

sub get_database{
  my ($self, $request) = @_;

  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  return $self->{impl}->get_database($name);
}

sub drop_database{
  my ($self, $request) = @_;

  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  my $deleteData = ($request->{'deleteData'}) ? $request->{'deleteData'} : undef;
  return $self->{impl}->drop_database($name, $deleteData);
}

sub get_databases{
  my ($self, $request) = @_;

  my $pattern = ($request->{'pattern'}) ? $request->{'pattern'} : undef;
  return $self->{impl}->get_databases($pattern);
}

sub get_all_databases{
  my ($self, $request) = @_;

  return $self->{impl}->get_all_databases();
}

sub alter_database{
  my ($self, $request) = @_;

  my $dbname = ($request->{'dbname'}) ? $request->{'dbname'} : undef;
  my $db = ($request->{'db'}) ? $request->{'db'} : undef;
  return $self->{impl}->alter_database($dbname, $db);
}

sub get_type{
  my ($self, $request) = @_;

  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  return $self->{impl}->get_type($name);
}

sub create_type{
  my ($self, $request) = @_;

  my $type = ($request->{'type'}) ? $request->{'type'} : undef;
  return $self->{impl}->create_type($type);
}

sub drop_type{
  my ($self, $request) = @_;

  my $type = ($request->{'type'}) ? $request->{'type'} : undef;
  return $self->{impl}->drop_type($type);
}

sub get_type_all{
  my ($self, $request) = @_;

  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  return $self->{impl}->get_type_all($name);
}

sub get_fields{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  return $self->{impl}->get_fields($db_name, $table_name);
}

sub get_schema{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $table_name = ($request->{'table_name'}) ? $request->{'table_name'} : undef;
  return $self->{impl}->get_schema($db_name, $table_name);
}

sub create_table{
  my ($self, $request) = @_;

  my $tbl = ($request->{'tbl'}) ? $request->{'tbl'} : undef;
  return $self->{impl}->create_table($tbl);
}

sub drop_table{
  my ($self, $request) = @_;

  my $dbname = ($request->{'dbname'}) ? $request->{'dbname'} : undef;
  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  my $deleteData = ($request->{'deleteData'}) ? $request->{'deleteData'} : undef;
  return $self->{impl}->drop_table($dbname, $name, $deleteData);
}

sub get_tables{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $pattern = ($request->{'pattern'}) ? $request->{'pattern'} : undef;
  return $self->{impl}->get_tables($db_name, $pattern);
}

sub get_all_tables{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  return $self->{impl}->get_all_tables($db_name);
}

sub get_table{
  my ($self, $request) = @_;

  my $dbname = ($request->{'dbname'}) ? $request->{'dbname'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  return $self->{impl}->get_table($dbname, $tbl_name);
}

sub alter_table{
  my ($self, $request) = @_;

  my $dbname = ($request->{'dbname'}) ? $request->{'dbname'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $new_tbl = ($request->{'new_tbl'}) ? $request->{'new_tbl'} : undef;
  return $self->{impl}->alter_table($dbname, $tbl_name, $new_tbl);
}

sub add_partition{
  my ($self, $request) = @_;

  my $new_part = ($request->{'new_part'}) ? $request->{'new_part'} : undef;
  return $self->{impl}->add_partition($new_part);
}

sub append_partition{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $part_vals = ($request->{'part_vals'}) ? $request->{'part_vals'} : undef;
  return $self->{impl}->append_partition($db_name, $tbl_name, $part_vals);
}

sub append_partition_by_name{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $part_name = ($request->{'part_name'}) ? $request->{'part_name'} : undef;
  return $self->{impl}->append_partition_by_name($db_name, $tbl_name, $part_name);
}

sub drop_partition{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $part_vals = ($request->{'part_vals'}) ? $request->{'part_vals'} : undef;
  my $deleteData = ($request->{'deleteData'}) ? $request->{'deleteData'} : undef;
  return $self->{impl}->drop_partition($db_name, $tbl_name, $part_vals, $deleteData);
}

sub drop_partition_by_name{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $part_name = ($request->{'part_name'}) ? $request->{'part_name'} : undef;
  my $deleteData = ($request->{'deleteData'}) ? $request->{'deleteData'} : undef;
  return $self->{impl}->drop_partition_by_name($db_name, $tbl_name, $part_name, $deleteData);
}

sub get_partition{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $part_vals = ($request->{'part_vals'}) ? $request->{'part_vals'} : undef;
  return $self->{impl}->get_partition($db_name, $tbl_name, $part_vals);
}

sub get_partition_with_auth{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $part_vals = ($request->{'part_vals'}) ? $request->{'part_vals'} : undef;
  my $user_name = ($request->{'user_name'}) ? $request->{'user_name'} : undef;
  my $group_names = ($request->{'group_names'}) ? $request->{'group_names'} : undef;
  return $self->{impl}->get_partition_with_auth($db_name, $tbl_name, $part_vals, $user_name, $group_names);
}

sub get_partition_by_name{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $part_name = ($request->{'part_name'}) ? $request->{'part_name'} : undef;
  return $self->{impl}->get_partition_by_name($db_name, $tbl_name, $part_name);
}

sub get_partitions{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $max_parts = ($request->{'max_parts'}) ? $request->{'max_parts'} : undef;
  return $self->{impl}->get_partitions($db_name, $tbl_name, $max_parts);
}

sub get_partitions_with_auth{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $max_parts = ($request->{'max_parts'}) ? $request->{'max_parts'} : undef;
  my $user_name = ($request->{'user_name'}) ? $request->{'user_name'} : undef;
  my $group_names = ($request->{'group_names'}) ? $request->{'group_names'} : undef;
  return $self->{impl}->get_partitions_with_auth($db_name, $tbl_name, $max_parts, $user_name, $group_names);
}

sub get_partition_names{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $max_parts = ($request->{'max_parts'}) ? $request->{'max_parts'} : undef;
  return $self->{impl}->get_partition_names($db_name, $tbl_name, $max_parts);
}

sub get_partitions_ps{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $part_vals = ($request->{'part_vals'}) ? $request->{'part_vals'} : undef;
  my $max_parts = ($request->{'max_parts'}) ? $request->{'max_parts'} : undef;
  return $self->{impl}->get_partitions_ps($db_name, $tbl_name, $part_vals, $max_parts);
}

sub get_partitions_ps_with_auth{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $part_vals = ($request->{'part_vals'}) ? $request->{'part_vals'} : undef;
  my $max_parts = ($request->{'max_parts'}) ? $request->{'max_parts'} : undef;
  my $user_name = ($request->{'user_name'}) ? $request->{'user_name'} : undef;
  my $group_names = ($request->{'group_names'}) ? $request->{'group_names'} : undef;
  return $self->{impl}->get_partitions_ps_with_auth($db_name, $tbl_name, $part_vals, $max_parts, $user_name, $group_names);
}

sub get_partition_names_ps{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $part_vals = ($request->{'part_vals'}) ? $request->{'part_vals'} : undef;
  my $max_parts = ($request->{'max_parts'}) ? $request->{'max_parts'} : undef;
  return $self->{impl}->get_partition_names_ps($db_name, $tbl_name, $part_vals, $max_parts);
}

sub get_partitions_by_filter{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $filter = ($request->{'filter'}) ? $request->{'filter'} : undef;
  my $max_parts = ($request->{'max_parts'}) ? $request->{'max_parts'} : undef;
  return $self->{impl}->get_partitions_by_filter($db_name, $tbl_name, $filter, $max_parts);
}

sub alter_partition{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $new_part = ($request->{'new_part'}) ? $request->{'new_part'} : undef;
  return $self->{impl}->alter_partition($db_name, $tbl_name, $new_part);
}

sub get_config_value{
  my ($self, $request) = @_;

  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  my $defaultValue = ($request->{'defaultValue'}) ? $request->{'defaultValue'} : undef;
  return $self->{impl}->get_config_value($name, $defaultValue);
}

sub partition_name_to_vals{
  my ($self, $request) = @_;

  my $part_name = ($request->{'part_name'}) ? $request->{'part_name'} : undef;
  return $self->{impl}->partition_name_to_vals($part_name);
}

sub partition_name_to_spec{
  my ($self, $request) = @_;

  my $part_name = ($request->{'part_name'}) ? $request->{'part_name'} : undef;
  return $self->{impl}->partition_name_to_spec($part_name);
}

sub add_index{
  my ($self, $request) = @_;

  my $new_index = ($request->{'new_index'}) ? $request->{'new_index'} : undef;
  my $index_table = ($request->{'index_table'}) ? $request->{'index_table'} : undef;
  return $self->{impl}->add_index($new_index, $index_table);
}

sub alter_index{
  my ($self, $request) = @_;

  my $dbname = ($request->{'dbname'}) ? $request->{'dbname'} : undef;
  my $base_tbl_name = ($request->{'base_tbl_name'}) ? $request->{'base_tbl_name'} : undef;
  my $idx_name = ($request->{'idx_name'}) ? $request->{'idx_name'} : undef;
  my $new_idx = ($request->{'new_idx'}) ? $request->{'new_idx'} : undef;
  return $self->{impl}->alter_index($dbname, $base_tbl_name, $idx_name, $new_idx);
}

sub drop_index_by_name{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $index_name = ($request->{'index_name'}) ? $request->{'index_name'} : undef;
  my $deleteData = ($request->{'deleteData'}) ? $request->{'deleteData'} : undef;
  return $self->{impl}->drop_index_by_name($db_name, $tbl_name, $index_name, $deleteData);
}

sub get_index_by_name{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $index_name = ($request->{'index_name'}) ? $request->{'index_name'} : undef;
  return $self->{impl}->get_index_by_name($db_name, $tbl_name, $index_name);
}

sub get_indexes{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $max_indexes = ($request->{'max_indexes'}) ? $request->{'max_indexes'} : undef;
  return $self->{impl}->get_indexes($db_name, $tbl_name, $max_indexes);
}

sub get_index_names{
  my ($self, $request) = @_;

  my $db_name = ($request->{'db_name'}) ? $request->{'db_name'} : undef;
  my $tbl_name = ($request->{'tbl_name'}) ? $request->{'tbl_name'} : undef;
  my $max_indexes = ($request->{'max_indexes'}) ? $request->{'max_indexes'} : undef;
  return $self->{impl}->get_index_names($db_name, $tbl_name, $max_indexes);
}

sub create_role{
  my ($self, $request) = @_;

  my $role = ($request->{'role'}) ? $request->{'role'} : undef;
  return $self->{impl}->create_role($role);
}

sub drop_role{
  my ($self, $request) = @_;

  my $role_name = ($request->{'role_name'}) ? $request->{'role_name'} : undef;
  return $self->{impl}->drop_role($role_name);
}

sub get_role_names{
  my ($self, $request) = @_;

  return $self->{impl}->get_role_names();
}

sub grant_role{
  my ($self, $request) = @_;

  my $role_name = ($request->{'role_name'}) ? $request->{'role_name'} : undef;
  my $principal_name = ($request->{'principal_name'}) ? $request->{'principal_name'} : undef;
  my $principal_type = ($request->{'principal_type'}) ? $request->{'principal_type'} : undef;
  my $grantor = ($request->{'grantor'}) ? $request->{'grantor'} : undef;
  my $grantorType = ($request->{'grantorType'}) ? $request->{'grantorType'} : undef;
  my $grant_option = ($request->{'grant_option'}) ? $request->{'grant_option'} : undef;
  return $self->{impl}->grant_role($role_name, $principal_name, $principal_type, $grantor, $grantorType, $grant_option);
}

sub revoke_role{
  my ($self, $request) = @_;

  my $role_name = ($request->{'role_name'}) ? $request->{'role_name'} : undef;
  my $principal_name = ($request->{'principal_name'}) ? $request->{'principal_name'} : undef;
  my $principal_type = ($request->{'principal_type'}) ? $request->{'principal_type'} : undef;
  return $self->{impl}->revoke_role($role_name, $principal_name, $principal_type);
}

sub list_roles{
  my ($self, $request) = @_;

  my $principal_name = ($request->{'principal_name'}) ? $request->{'principal_name'} : undef;
  my $principal_type = ($request->{'principal_type'}) ? $request->{'principal_type'} : undef;
  return $self->{impl}->list_roles($principal_name, $principal_type);
}

sub get_privilege_set{
  my ($self, $request) = @_;

  my $hiveObject = ($request->{'hiveObject'}) ? $request->{'hiveObject'} : undef;
  my $user_name = ($request->{'user_name'}) ? $request->{'user_name'} : undef;
  my $group_names = ($request->{'group_names'}) ? $request->{'group_names'} : undef;
  return $self->{impl}->get_privilege_set($hiveObject, $user_name, $group_names);
}

sub list_privileges{
  my ($self, $request) = @_;

  my $principal_name = ($request->{'principal_name'}) ? $request->{'principal_name'} : undef;
  my $principal_type = ($request->{'principal_type'}) ? $request->{'principal_type'} : undef;
  my $hiveObject = ($request->{'hiveObject'}) ? $request->{'hiveObject'} : undef;
  return $self->{impl}->list_privileges($principal_name, $principal_type, $hiveObject);
}

sub grant_privileges{
  my ($self, $request) = @_;

  my $privileges = ($request->{'privileges'}) ? $request->{'privileges'} : undef;
  return $self->{impl}->grant_privileges($privileges);
}

sub revoke_privileges{
  my ($self, $request) = @_;

  my $privileges = ($request->{'privileges'}) ? $request->{'privileges'} : undef;
  return $self->{impl}->revoke_privileges($privileges);
}

sub get_delegation_token{
  my ($self, $request) = @_;

  my $renewer_kerberos_principal_name = ($request->{'renewer_kerberos_principal_name'}) ? $request->{'renewer_kerberos_principal_name'} : undef;
  return $self->{impl}->get_delegation_token($renewer_kerberos_principal_name);
}

sub get_delegation_token_with_signature{
  my ($self, $request) = @_;

  my $renewer_kerberos_principal_name = ($request->{'renewer_kerberos_principal_name'}) ? $request->{'renewer_kerberos_principal_name'} : undef;
  my $token_signature = ($request->{'token_signature'}) ? $request->{'token_signature'} : undef;
  return $self->{impl}->get_delegation_token_with_signature($renewer_kerberos_principal_name, $token_signature);
}

sub renew_delegation_token{
  my ($self, $request) = @_;

  my $token_str_form = ($request->{'token_str_form'}) ? $request->{'token_str_form'} : undef;
  return $self->{impl}->renew_delegation_token($token_str_form);
}

sub cancel_delegation_token{
  my ($self, $request) = @_;

  my $token_str_form = ($request->{'token_str_form'}) ? $request->{'token_str_form'} : undef;
  return $self->{impl}->cancel_delegation_token($token_str_form);
}

package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastoreClient;

use base qw(Thrift::API::HiveClient::Facebook::FB303::FacebookServiceClient);
use base qw(Thrift::API::HiveClient::Metastore::ThriftHiveMetastoreIf);
sub new {
  my ($classname, $input, $output) = @_;
  my $self      = {};
  $self = $classname->SUPER::new($input, $output);
  return bless($self,$classname);
}

sub create_database{
  my $self = shift;
  my $database = shift;

    $self->send_create_database($database);
  $self->recv_create_database();
}

sub send_create_database{
  my $self = shift;
  my $database = shift;

  $self->{output}->writeMessageBegin('create_database', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_create_database_args();
  $args->{database} = $database;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_create_database{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_create_database_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  if (defined $result->{o3}) {
    die $result->{o3};
  }
  return;
}
sub get_database{
  my $self = shift;
  my $name = shift;

    $self->send_get_database($name);
  return $self->recv_get_database();
}

sub send_get_database{
  my $self = shift;
  my $name = shift;

  $self->{output}->writeMessageBegin('get_database', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_database_args();
  $args->{name} = $name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_database{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_database_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  die "get_database failed: unknown result";
}
sub drop_database{
  my $self = shift;
  my $name = shift;
  my $deleteData = shift;

    $self->send_drop_database($name, $deleteData);
  $self->recv_drop_database();
}

sub send_drop_database{
  my $self = shift;
  my $name = shift;
  my $deleteData = shift;

  $self->{output}->writeMessageBegin('drop_database', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_drop_database_args();
  $args->{name} = $name;
  $args->{deleteData} = $deleteData;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_drop_database{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_drop_database_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  if (defined $result->{o3}) {
    die $result->{o3};
  }
  return;
}
sub get_databases{
  my $self = shift;
  my $pattern = shift;

    $self->send_get_databases($pattern);
  return $self->recv_get_databases();
}

sub send_get_databases{
  my $self = shift;
  my $pattern = shift;

  $self->{output}->writeMessageBegin('get_databases', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_databases_args();
  $args->{pattern} = $pattern;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_databases{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_databases_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  die "get_databases failed: unknown result";
}
sub get_all_databases{
  my $self = shift;

    $self->send_get_all_databases();
  return $self->recv_get_all_databases();
}

sub send_get_all_databases{
  my $self = shift;

  $self->{output}->writeMessageBegin('get_all_databases', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_all_databases_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_all_databases{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_all_databases_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  die "get_all_databases failed: unknown result";
}
sub alter_database{
  my $self = shift;
  my $dbname = shift;
  my $db = shift;

    $self->send_alter_database($dbname, $db);
  $self->recv_alter_database();
}

sub send_alter_database{
  my $self = shift;
  my $dbname = shift;
  my $db = shift;

  $self->{output}->writeMessageBegin('alter_database', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_alter_database_args();
  $args->{dbname} = $dbname;
  $args->{db} = $db;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_alter_database{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_alter_database_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  return;
}
sub get_type{
  my $self = shift;
  my $name = shift;

    $self->send_get_type($name);
  return $self->recv_get_type();
}

sub send_get_type{
  my $self = shift;
  my $name = shift;

  $self->{output}->writeMessageBegin('get_type', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_type_args();
  $args->{name} = $name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_type{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_type_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  die "get_type failed: unknown result";
}
sub create_type{
  my $self = shift;
  my $type = shift;

    $self->send_create_type($type);
  return $self->recv_create_type();
}

sub send_create_type{
  my $self = shift;
  my $type = shift;

  $self->{output}->writeMessageBegin('create_type', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_create_type_args();
  $args->{type} = $type;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_create_type{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_create_type_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  if (defined $result->{o3}) {
    die $result->{o3};
  }
  die "create_type failed: unknown result";
}
sub drop_type{
  my $self = shift;
  my $type = shift;

    $self->send_drop_type($type);
  return $self->recv_drop_type();
}

sub send_drop_type{
  my $self = shift;
  my $type = shift;

  $self->{output}->writeMessageBegin('drop_type', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_drop_type_args();
  $args->{type} = $type;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_drop_type{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_drop_type_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  die "drop_type failed: unknown result";
}
sub get_type_all{
  my $self = shift;
  my $name = shift;

    $self->send_get_type_all($name);
  return $self->recv_get_type_all();
}

sub send_get_type_all{
  my $self = shift;
  my $name = shift;

  $self->{output}->writeMessageBegin('get_type_all', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_type_all_args();
  $args->{name} = $name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_type_all{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_type_all_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  die "get_type_all failed: unknown result";
}
sub get_fields{
  my $self = shift;
  my $db_name = shift;
  my $table_name = shift;

    $self->send_get_fields($db_name, $table_name);
  return $self->recv_get_fields();
}

sub send_get_fields{
  my $self = shift;
  my $db_name = shift;
  my $table_name = shift;

  $self->{output}->writeMessageBegin('get_fields', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_fields_args();
  $args->{db_name} = $db_name;
  $args->{table_name} = $table_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_fields{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_fields_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  if (defined $result->{o3}) {
    die $result->{o3};
  }
  die "get_fields failed: unknown result";
}
sub get_schema{
  my $self = shift;
  my $db_name = shift;
  my $table_name = shift;

    $self->send_get_schema($db_name, $table_name);
  return $self->recv_get_schema();
}

sub send_get_schema{
  my $self = shift;
  my $db_name = shift;
  my $table_name = shift;

  $self->{output}->writeMessageBegin('get_schema', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_schema_args();
  $args->{db_name} = $db_name;
  $args->{table_name} = $table_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_schema{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_schema_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  if (defined $result->{o3}) {
    die $result->{o3};
  }
  die "get_schema failed: unknown result";
}
sub create_table{
  my $self = shift;
  my $tbl = shift;

    $self->send_create_table($tbl);
  $self->recv_create_table();
}

sub send_create_table{
  my $self = shift;
  my $tbl = shift;

  $self->{output}->writeMessageBegin('create_table', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_create_table_args();
  $args->{tbl} = $tbl;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_create_table{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_create_table_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  if (defined $result->{o3}) {
    die $result->{o3};
  }
  if (defined $result->{o4}) {
    die $result->{o4};
  }
  return;
}
sub drop_table{
  my $self = shift;
  my $dbname = shift;
  my $name = shift;
  my $deleteData = shift;

    $self->send_drop_table($dbname, $name, $deleteData);
  $self->recv_drop_table();
}

sub send_drop_table{
  my $self = shift;
  my $dbname = shift;
  my $name = shift;
  my $deleteData = shift;

  $self->{output}->writeMessageBegin('drop_table', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_drop_table_args();
  $args->{dbname} = $dbname;
  $args->{name} = $name;
  $args->{deleteData} = $deleteData;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_drop_table{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_drop_table_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o3}) {
    die $result->{o3};
  }
  return;
}
sub get_tables{
  my $self = shift;
  my $db_name = shift;
  my $pattern = shift;

    $self->send_get_tables($db_name, $pattern);
  return $self->recv_get_tables();
}

sub send_get_tables{
  my $self = shift;
  my $db_name = shift;
  my $pattern = shift;

  $self->{output}->writeMessageBegin('get_tables', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_tables_args();
  $args->{db_name} = $db_name;
  $args->{pattern} = $pattern;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_tables{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_tables_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  die "get_tables failed: unknown result";
}
sub get_all_tables{
  my $self = shift;
  my $db_name = shift;

    $self->send_get_all_tables($db_name);
  return $self->recv_get_all_tables();
}

sub send_get_all_tables{
  my $self = shift;
  my $db_name = shift;

  $self->{output}->writeMessageBegin('get_all_tables', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_all_tables_args();
  $args->{db_name} = $db_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_all_tables{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_all_tables_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  die "get_all_tables failed: unknown result";
}
sub get_table{
  my $self = shift;
  my $dbname = shift;
  my $tbl_name = shift;

    $self->send_get_table($dbname, $tbl_name);
  return $self->recv_get_table();
}

sub send_get_table{
  my $self = shift;
  my $dbname = shift;
  my $tbl_name = shift;

  $self->{output}->writeMessageBegin('get_table', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_table_args();
  $args->{dbname} = $dbname;
  $args->{tbl_name} = $tbl_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_table{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_table_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  die "get_table failed: unknown result";
}
sub alter_table{
  my $self = shift;
  my $dbname = shift;
  my $tbl_name = shift;
  my $new_tbl = shift;

    $self->send_alter_table($dbname, $tbl_name, $new_tbl);
  $self->recv_alter_table();
}

sub send_alter_table{
  my $self = shift;
  my $dbname = shift;
  my $tbl_name = shift;
  my $new_tbl = shift;

  $self->{output}->writeMessageBegin('alter_table', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_alter_table_args();
  $args->{dbname} = $dbname;
  $args->{tbl_name} = $tbl_name;
  $args->{new_tbl} = $new_tbl;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_alter_table{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_alter_table_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  return;
}
sub add_partition{
  my $self = shift;
  my $new_part = shift;

    $self->send_add_partition($new_part);
  return $self->recv_add_partition();
}

sub send_add_partition{
  my $self = shift;
  my $new_part = shift;

  $self->{output}->writeMessageBegin('add_partition', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_add_partition_args();
  $args->{new_part} = $new_part;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_add_partition{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_add_partition_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  if (defined $result->{o3}) {
    die $result->{o3};
  }
  die "add_partition failed: unknown result";
}
sub append_partition{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;

    $self->send_append_partition($db_name, $tbl_name, $part_vals);
  return $self->recv_append_partition();
}

sub send_append_partition{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;

  $self->{output}->writeMessageBegin('append_partition', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_append_partition_args();
  $args->{db_name} = $db_name;
  $args->{tbl_name} = $tbl_name;
  $args->{part_vals} = $part_vals;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_append_partition{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_append_partition_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  if (defined $result->{o3}) {
    die $result->{o3};
  }
  die "append_partition failed: unknown result";
}
sub append_partition_by_name{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_name = shift;

    $self->send_append_partition_by_name($db_name, $tbl_name, $part_name);
  return $self->recv_append_partition_by_name();
}

sub send_append_partition_by_name{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_name = shift;

  $self->{output}->writeMessageBegin('append_partition_by_name', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_append_partition_by_name_args();
  $args->{db_name} = $db_name;
  $args->{tbl_name} = $tbl_name;
  $args->{part_name} = $part_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_append_partition_by_name{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_append_partition_by_name_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  if (defined $result->{o3}) {
    die $result->{o3};
  }
  die "append_partition_by_name failed: unknown result";
}
sub drop_partition{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;
  my $deleteData = shift;

    $self->send_drop_partition($db_name, $tbl_name, $part_vals, $deleteData);
  return $self->recv_drop_partition();
}

sub send_drop_partition{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;
  my $deleteData = shift;

  $self->{output}->writeMessageBegin('drop_partition', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_drop_partition_args();
  $args->{db_name} = $db_name;
  $args->{tbl_name} = $tbl_name;
  $args->{part_vals} = $part_vals;
  $args->{deleteData} = $deleteData;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_drop_partition{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_drop_partition_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  die "drop_partition failed: unknown result";
}
sub drop_partition_by_name{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_name = shift;
  my $deleteData = shift;

    $self->send_drop_partition_by_name($db_name, $tbl_name, $part_name, $deleteData);
  return $self->recv_drop_partition_by_name();
}

sub send_drop_partition_by_name{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_name = shift;
  my $deleteData = shift;

  $self->{output}->writeMessageBegin('drop_partition_by_name', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_drop_partition_by_name_args();
  $args->{db_name} = $db_name;
  $args->{tbl_name} = $tbl_name;
  $args->{part_name} = $part_name;
  $args->{deleteData} = $deleteData;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_drop_partition_by_name{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_drop_partition_by_name_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  die "drop_partition_by_name failed: unknown result";
}
sub get_partition{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;

    $self->send_get_partition($db_name, $tbl_name, $part_vals);
  return $self->recv_get_partition();
}

sub send_get_partition{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;

  $self->{output}->writeMessageBegin('get_partition', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partition_args();
  $args->{db_name} = $db_name;
  $args->{tbl_name} = $tbl_name;
  $args->{part_vals} = $part_vals;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_partition{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partition_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  die "get_partition failed: unknown result";
}
sub get_partition_with_auth{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;
  my $user_name = shift;
  my $group_names = shift;

    $self->send_get_partition_with_auth($db_name, $tbl_name, $part_vals, $user_name, $group_names);
  return $self->recv_get_partition_with_auth();
}

sub send_get_partition_with_auth{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;
  my $user_name = shift;
  my $group_names = shift;

  $self->{output}->writeMessageBegin('get_partition_with_auth', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partition_with_auth_args();
  $args->{db_name} = $db_name;
  $args->{tbl_name} = $tbl_name;
  $args->{part_vals} = $part_vals;
  $args->{user_name} = $user_name;
  $args->{group_names} = $group_names;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_partition_with_auth{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partition_with_auth_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  die "get_partition_with_auth failed: unknown result";
}
sub get_partition_by_name{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_name = shift;

    $self->send_get_partition_by_name($db_name, $tbl_name, $part_name);
  return $self->recv_get_partition_by_name();
}

sub send_get_partition_by_name{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_name = shift;

  $self->{output}->writeMessageBegin('get_partition_by_name', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partition_by_name_args();
  $args->{db_name} = $db_name;
  $args->{tbl_name} = $tbl_name;
  $args->{part_name} = $part_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_partition_by_name{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partition_by_name_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  die "get_partition_by_name failed: unknown result";
}
sub get_partitions{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $max_parts = shift;

    $self->send_get_partitions($db_name, $tbl_name, $max_parts);
  return $self->recv_get_partitions();
}

sub send_get_partitions{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $max_parts = shift;

  $self->{output}->writeMessageBegin('get_partitions', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partitions_args();
  $args->{db_name} = $db_name;
  $args->{tbl_name} = $tbl_name;
  $args->{max_parts} = $max_parts;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_partitions{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partitions_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  die "get_partitions failed: unknown result";
}
sub get_partitions_with_auth{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $max_parts = shift;
  my $user_name = shift;
  my $group_names = shift;

    $self->send_get_partitions_with_auth($db_name, $tbl_name, $max_parts, $user_name, $group_names);
  return $self->recv_get_partitions_with_auth();
}

sub send_get_partitions_with_auth{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $max_parts = shift;
  my $user_name = shift;
  my $group_names = shift;

  $self->{output}->writeMessageBegin('get_partitions_with_auth', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partitions_with_auth_args();
  $args->{db_name} = $db_name;
  $args->{tbl_name} = $tbl_name;
  $args->{max_parts} = $max_parts;
  $args->{user_name} = $user_name;
  $args->{group_names} = $group_names;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_partitions_with_auth{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partitions_with_auth_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  die "get_partitions_with_auth failed: unknown result";
}
sub get_partition_names{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $max_parts = shift;

    $self->send_get_partition_names($db_name, $tbl_name, $max_parts);
  return $self->recv_get_partition_names();
}

sub send_get_partition_names{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $max_parts = shift;

  $self->{output}->writeMessageBegin('get_partition_names', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partition_names_args();
  $args->{db_name} = $db_name;
  $args->{tbl_name} = $tbl_name;
  $args->{max_parts} = $max_parts;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_partition_names{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partition_names_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  die "get_partition_names failed: unknown result";
}
sub get_partitions_ps{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;
  my $max_parts = shift;

    $self->send_get_partitions_ps($db_name, $tbl_name, $part_vals, $max_parts);
  return $self->recv_get_partitions_ps();
}

sub send_get_partitions_ps{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;
  my $max_parts = shift;

  $self->{output}->writeMessageBegin('get_partitions_ps', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partitions_ps_args();
  $args->{db_name} = $db_name;
  $args->{tbl_name} = $tbl_name;
  $args->{part_vals} = $part_vals;
  $args->{max_parts} = $max_parts;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_partitions_ps{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partitions_ps_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  die "get_partitions_ps failed: unknown result";
}
sub get_partitions_ps_with_auth{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;
  my $max_parts = shift;
  my $user_name = shift;
  my $group_names = shift;

    $self->send_get_partitions_ps_with_auth($db_name, $tbl_name, $part_vals, $max_parts, $user_name, $group_names);
  return $self->recv_get_partitions_ps_with_auth();
}

sub send_get_partitions_ps_with_auth{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;
  my $max_parts = shift;
  my $user_name = shift;
  my $group_names = shift;

  $self->{output}->writeMessageBegin('get_partitions_ps_with_auth', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partitions_ps_with_auth_args();
  $args->{db_name} = $db_name;
  $args->{tbl_name} = $tbl_name;
  $args->{part_vals} = $part_vals;
  $args->{max_parts} = $max_parts;
  $args->{user_name} = $user_name;
  $args->{group_names} = $group_names;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_partitions_ps_with_auth{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partitions_ps_with_auth_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  die "get_partitions_ps_with_auth failed: unknown result";
}
sub get_partition_names_ps{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;
  my $max_parts = shift;

    $self->send_get_partition_names_ps($db_name, $tbl_name, $part_vals, $max_parts);
  return $self->recv_get_partition_names_ps();
}

sub send_get_partition_names_ps{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $part_vals = shift;
  my $max_parts = shift;

  $self->{output}->writeMessageBegin('get_partition_names_ps', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partition_names_ps_args();
  $args->{db_name} = $db_name;
  $args->{tbl_name} = $tbl_name;
  $args->{part_vals} = $part_vals;
  $args->{max_parts} = $max_parts;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_partition_names_ps{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partition_names_ps_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  die "get_partition_names_ps failed: unknown result";
}
sub get_partitions_by_filter{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $filter = shift;
  my $max_parts = shift;

    $self->send_get_partitions_by_filter($db_name, $tbl_name, $filter, $max_parts);
  return $self->recv_get_partitions_by_filter();
}

sub send_get_partitions_by_filter{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $filter = shift;
  my $max_parts = shift;

  $self->{output}->writeMessageBegin('get_partitions_by_filter', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partitions_by_filter_args();
  $args->{db_name} = $db_name;
  $args->{tbl_name} = $tbl_name;
  $args->{filter} = $filter;
  $args->{max_parts} = $max_parts;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_partitions_by_filter{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partitions_by_filter_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  die "get_partitions_by_filter failed: unknown result";
}
sub alter_partition{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $new_part = shift;

    $self->send_alter_partition($db_name, $tbl_name, $new_part);
  $self->recv_alter_partition();
}

sub send_alter_partition{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $new_part = shift;

  $self->{output}->writeMessageBegin('alter_partition', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_alter_partition_args();
  $args->{db_name} = $db_name;
  $args->{tbl_name} = $tbl_name;
  $args->{new_part} = $new_part;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_alter_partition{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_alter_partition_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  return;
}
sub get_config_value{
  my $self = shift;
  my $name = shift;
  my $defaultValue = shift;

    $self->send_get_config_value($name, $defaultValue);
  return $self->recv_get_config_value();
}

sub send_get_config_value{
  my $self = shift;
  my $name = shift;
  my $defaultValue = shift;

  $self->{output}->writeMessageBegin('get_config_value', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_config_value_args();
  $args->{name} = $name;
  $args->{defaultValue} = $defaultValue;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_config_value{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_config_value_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  die "get_config_value failed: unknown result";
}
sub partition_name_to_vals{
  my $self = shift;
  my $part_name = shift;

    $self->send_partition_name_to_vals($part_name);
  return $self->recv_partition_name_to_vals();
}

sub send_partition_name_to_vals{
  my $self = shift;
  my $part_name = shift;

  $self->{output}->writeMessageBegin('partition_name_to_vals', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_partition_name_to_vals_args();
  $args->{part_name} = $part_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_partition_name_to_vals{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_partition_name_to_vals_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  die "partition_name_to_vals failed: unknown result";
}
sub partition_name_to_spec{
  my $self = shift;
  my $part_name = shift;

    $self->send_partition_name_to_spec($part_name);
  return $self->recv_partition_name_to_spec();
}

sub send_partition_name_to_spec{
  my $self = shift;
  my $part_name = shift;

  $self->{output}->writeMessageBegin('partition_name_to_spec', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_partition_name_to_spec_args();
  $args->{part_name} = $part_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_partition_name_to_spec{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_partition_name_to_spec_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  die "partition_name_to_spec failed: unknown result";
}
sub add_index{
  my $self = shift;
  my $new_index = shift;
  my $index_table = shift;

    $self->send_add_index($new_index, $index_table);
  return $self->recv_add_index();
}

sub send_add_index{
  my $self = shift;
  my $new_index = shift;
  my $index_table = shift;

  $self->{output}->writeMessageBegin('add_index', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_add_index_args();
  $args->{new_index} = $new_index;
  $args->{index_table} = $index_table;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_add_index{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_add_index_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  if (defined $result->{o3}) {
    die $result->{o3};
  }
  die "add_index failed: unknown result";
}
sub alter_index{
  my $self = shift;
  my $dbname = shift;
  my $base_tbl_name = shift;
  my $idx_name = shift;
  my $new_idx = shift;

    $self->send_alter_index($dbname, $base_tbl_name, $idx_name, $new_idx);
  $self->recv_alter_index();
}

sub send_alter_index{
  my $self = shift;
  my $dbname = shift;
  my $base_tbl_name = shift;
  my $idx_name = shift;
  my $new_idx = shift;

  $self->{output}->writeMessageBegin('alter_index', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_alter_index_args();
  $args->{dbname} = $dbname;
  $args->{base_tbl_name} = $base_tbl_name;
  $args->{idx_name} = $idx_name;
  $args->{new_idx} = $new_idx;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_alter_index{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_alter_index_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  return;
}
sub drop_index_by_name{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $index_name = shift;
  my $deleteData = shift;

    $self->send_drop_index_by_name($db_name, $tbl_name, $index_name, $deleteData);
  return $self->recv_drop_index_by_name();
}

sub send_drop_index_by_name{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $index_name = shift;
  my $deleteData = shift;

  $self->{output}->writeMessageBegin('drop_index_by_name', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_drop_index_by_name_args();
  $args->{db_name} = $db_name;
  $args->{tbl_name} = $tbl_name;
  $args->{index_name} = $index_name;
  $args->{deleteData} = $deleteData;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_drop_index_by_name{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_drop_index_by_name_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  die "drop_index_by_name failed: unknown result";
}
sub get_index_by_name{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $index_name = shift;

    $self->send_get_index_by_name($db_name, $tbl_name, $index_name);
  return $self->recv_get_index_by_name();
}

sub send_get_index_by_name{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $index_name = shift;

  $self->{output}->writeMessageBegin('get_index_by_name', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_index_by_name_args();
  $args->{db_name} = $db_name;
  $args->{tbl_name} = $tbl_name;
  $args->{index_name} = $index_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_index_by_name{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_index_by_name_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  die "get_index_by_name failed: unknown result";
}
sub get_indexes{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $max_indexes = shift;

    $self->send_get_indexes($db_name, $tbl_name, $max_indexes);
  return $self->recv_get_indexes();
}

sub send_get_indexes{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $max_indexes = shift;

  $self->{output}->writeMessageBegin('get_indexes', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_indexes_args();
  $args->{db_name} = $db_name;
  $args->{tbl_name} = $tbl_name;
  $args->{max_indexes} = $max_indexes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_indexes{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_indexes_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  die "get_indexes failed: unknown result";
}
sub get_index_names{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $max_indexes = shift;

    $self->send_get_index_names($db_name, $tbl_name, $max_indexes);
  return $self->recv_get_index_names();
}

sub send_get_index_names{
  my $self = shift;
  my $db_name = shift;
  my $tbl_name = shift;
  my $max_indexes = shift;

  $self->{output}->writeMessageBegin('get_index_names', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_index_names_args();
  $args->{db_name} = $db_name;
  $args->{tbl_name} = $tbl_name;
  $args->{max_indexes} = $max_indexes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_index_names{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_index_names_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o2}) {
    die $result->{o2};
  }
  die "get_index_names failed: unknown result";
}
sub create_role{
  my $self = shift;
  my $role = shift;

    $self->send_create_role($role);
  return $self->recv_create_role();
}

sub send_create_role{
  my $self = shift;
  my $role = shift;

  $self->{output}->writeMessageBegin('create_role', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_create_role_args();
  $args->{role} = $role;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_create_role{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_create_role_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  die "create_role failed: unknown result";
}
sub drop_role{
  my $self = shift;
  my $role_name = shift;

    $self->send_drop_role($role_name);
  return $self->recv_drop_role();
}

sub send_drop_role{
  my $self = shift;
  my $role_name = shift;

  $self->{output}->writeMessageBegin('drop_role', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_drop_role_args();
  $args->{role_name} = $role_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_drop_role{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_drop_role_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  die "drop_role failed: unknown result";
}
sub get_role_names{
  my $self = shift;

    $self->send_get_role_names();
  return $self->recv_get_role_names();
}

sub send_get_role_names{
  my $self = shift;

  $self->{output}->writeMessageBegin('get_role_names', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_role_names_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_role_names{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_role_names_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  die "get_role_names failed: unknown result";
}
sub grant_role{
  my $self = shift;
  my $role_name = shift;
  my $principal_name = shift;
  my $principal_type = shift;
  my $grantor = shift;
  my $grantorType = shift;
  my $grant_option = shift;

    $self->send_grant_role($role_name, $principal_name, $principal_type, $grantor, $grantorType, $grant_option);
  return $self->recv_grant_role();
}

sub send_grant_role{
  my $self = shift;
  my $role_name = shift;
  my $principal_name = shift;
  my $principal_type = shift;
  my $grantor = shift;
  my $grantorType = shift;
  my $grant_option = shift;

  $self->{output}->writeMessageBegin('grant_role', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_grant_role_args();
  $args->{role_name} = $role_name;
  $args->{principal_name} = $principal_name;
  $args->{principal_type} = $principal_type;
  $args->{grantor} = $grantor;
  $args->{grantorType} = $grantorType;
  $args->{grant_option} = $grant_option;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_grant_role{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_grant_role_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  die "grant_role failed: unknown result";
}
sub revoke_role{
  my $self = shift;
  my $role_name = shift;
  my $principal_name = shift;
  my $principal_type = shift;

    $self->send_revoke_role($role_name, $principal_name, $principal_type);
  return $self->recv_revoke_role();
}

sub send_revoke_role{
  my $self = shift;
  my $role_name = shift;
  my $principal_name = shift;
  my $principal_type = shift;

  $self->{output}->writeMessageBegin('revoke_role', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_revoke_role_args();
  $args->{role_name} = $role_name;
  $args->{principal_name} = $principal_name;
  $args->{principal_type} = $principal_type;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_revoke_role{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_revoke_role_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  die "revoke_role failed: unknown result";
}
sub list_roles{
  my $self = shift;
  my $principal_name = shift;
  my $principal_type = shift;

    $self->send_list_roles($principal_name, $principal_type);
  return $self->recv_list_roles();
}

sub send_list_roles{
  my $self = shift;
  my $principal_name = shift;
  my $principal_type = shift;

  $self->{output}->writeMessageBegin('list_roles', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_list_roles_args();
  $args->{principal_name} = $principal_name;
  $args->{principal_type} = $principal_type;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_list_roles{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_list_roles_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  die "list_roles failed: unknown result";
}
sub get_privilege_set{
  my $self = shift;
  my $hiveObject = shift;
  my $user_name = shift;
  my $group_names = shift;

    $self->send_get_privilege_set($hiveObject, $user_name, $group_names);
  return $self->recv_get_privilege_set();
}

sub send_get_privilege_set{
  my $self = shift;
  my $hiveObject = shift;
  my $user_name = shift;
  my $group_names = shift;

  $self->{output}->writeMessageBegin('get_privilege_set', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_privilege_set_args();
  $args->{hiveObject} = $hiveObject;
  $args->{user_name} = $user_name;
  $args->{group_names} = $group_names;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_privilege_set{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_privilege_set_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  die "get_privilege_set failed: unknown result";
}
sub list_privileges{
  my $self = shift;
  my $principal_name = shift;
  my $principal_type = shift;
  my $hiveObject = shift;

    $self->send_list_privileges($principal_name, $principal_type, $hiveObject);
  return $self->recv_list_privileges();
}

sub send_list_privileges{
  my $self = shift;
  my $principal_name = shift;
  my $principal_type = shift;
  my $hiveObject = shift;

  $self->{output}->writeMessageBegin('list_privileges', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_list_privileges_args();
  $args->{principal_name} = $principal_name;
  $args->{principal_type} = $principal_type;
  $args->{hiveObject} = $hiveObject;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_list_privileges{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_list_privileges_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  die "list_privileges failed: unknown result";
}
sub grant_privileges{
  my $self = shift;
  my $privileges = shift;

    $self->send_grant_privileges($privileges);
  return $self->recv_grant_privileges();
}

sub send_grant_privileges{
  my $self = shift;
  my $privileges = shift;

  $self->{output}->writeMessageBegin('grant_privileges', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_grant_privileges_args();
  $args->{privileges} = $privileges;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_grant_privileges{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_grant_privileges_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  die "grant_privileges failed: unknown result";
}
sub revoke_privileges{
  my $self = shift;
  my $privileges = shift;

    $self->send_revoke_privileges($privileges);
  return $self->recv_revoke_privileges();
}

sub send_revoke_privileges{
  my $self = shift;
  my $privileges = shift;

  $self->{output}->writeMessageBegin('revoke_privileges', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_revoke_privileges_args();
  $args->{privileges} = $privileges;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_revoke_privileges{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_revoke_privileges_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  die "revoke_privileges failed: unknown result";
}
sub get_delegation_token{
  my $self = shift;
  my $renewer_kerberos_principal_name = shift;

    $self->send_get_delegation_token($renewer_kerberos_principal_name);
  return $self->recv_get_delegation_token();
}

sub send_get_delegation_token{
  my $self = shift;
  my $renewer_kerberos_principal_name = shift;

  $self->{output}->writeMessageBegin('get_delegation_token', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_delegation_token_args();
  $args->{renewer_kerberos_principal_name} = $renewer_kerberos_principal_name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_delegation_token{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_delegation_token_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  die "get_delegation_token failed: unknown result";
}
sub get_delegation_token_with_signature{
  my $self = shift;
  my $renewer_kerberos_principal_name = shift;
  my $token_signature = shift;

    $self->send_get_delegation_token_with_signature($renewer_kerberos_principal_name, $token_signature);
  return $self->recv_get_delegation_token_with_signature();
}

sub send_get_delegation_token_with_signature{
  my $self = shift;
  my $renewer_kerberos_principal_name = shift;
  my $token_signature = shift;

  $self->{output}->writeMessageBegin('get_delegation_token_with_signature', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_delegation_token_with_signature_args();
  $args->{renewer_kerberos_principal_name} = $renewer_kerberos_principal_name;
  $args->{token_signature} = $token_signature;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_delegation_token_with_signature{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_delegation_token_with_signature_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  die "get_delegation_token_with_signature failed: unknown result";
}
sub renew_delegation_token{
  my $self = shift;
  my $token_str_form = shift;

    $self->send_renew_delegation_token($token_str_form);
  return $self->recv_renew_delegation_token();
}

sub send_renew_delegation_token{
  my $self = shift;
  my $token_str_form = shift;

  $self->{output}->writeMessageBegin('renew_delegation_token', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_renew_delegation_token_args();
  $args->{token_str_form} = $token_str_form;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_renew_delegation_token{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_renew_delegation_token_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{o1}) {
    die $result->{o1};
  }
  die "renew_delegation_token failed: unknown result";
}
sub cancel_delegation_token{
  my $self = shift;
  my $token_str_form = shift;

    $self->send_cancel_delegation_token($token_str_form);
  $self->recv_cancel_delegation_token();
}

sub send_cancel_delegation_token{
  my $self = shift;
  my $token_str_form = shift;

  $self->{output}->writeMessageBegin('cancel_delegation_token', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_cancel_delegation_token_args();
  $args->{token_str_form} = $token_str_form;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_cancel_delegation_token{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_cancel_delegation_token_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{o1}) {
    die $result->{o1};
  }
  return;
}
package
   Thrift::API::HiveClient::Metastore::ThriftHiveMetastoreProcessor;

use strict;
use base qw(Thrift::API::HiveClient::Facebook::FB303::FacebookServiceProcessor);

sub process {
    my ($self, $input, $output) = @_;
    my $rseqid = 0;
    my $fname  = undef;
    my $mtype  = 0;

    $input->readMessageBegin(\$fname, \$mtype, \$rseqid);
    my $methodname = 'process_'.$fname;
    if (!$self->can($methodname)) {
      $input->skip(TType::STRUCT);
      $input->readMessageEnd();
      my $x = new TApplicationException('Function '.$fname.' not implemented.', TApplicationException::UNKNOWN_METHOD);
      $output->writeMessageBegin($fname, TMessageType::EXCEPTION, $rseqid);
      $x->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      return;
    }
    $self->$methodname($rseqid, $input, $output);
    return 1;
}

sub process_create_database {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_create_database_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_create_database_result();
    eval {
      $self->{handler}->create_database($args->database);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::AlreadyExistsException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::InvalidObjectException') ){ 
      $result->{o2} = $@;
        }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::MetaException') ){ 
      $result->{o3} = $@;
    }
    $output->writeMessageBegin('create_database', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_database {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_database_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_database_result();
    eval {
      $result->{success} = $self->{handler}->get_database($args->name);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::NoSuchObjectException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::MetaException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('get_database', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_drop_database {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_drop_database_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_drop_database_result();
    eval {
      $self->{handler}->drop_database($args->name, $args->deleteData);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::NoSuchObjectException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::InvalidOperationException') ){ 
      $result->{o2} = $@;
        }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::MetaException') ){ 
      $result->{o3} = $@;
    }
    $output->writeMessageBegin('drop_database', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_databases {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_databases_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_databases_result();
    eval {
      $result->{success} = $self->{handler}->get_databases($args->pattern);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::MetaException') ){ 
      $result->{o1} = $@;
    }
    $output->writeMessageBegin('get_databases', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_all_databases {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_all_databases_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_all_databases_result();
    eval {
      $result->{success} = $self->{handler}->get_all_databases();
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::MetaException') ){ 
      $result->{o1} = $@;
    }
    $output->writeMessageBegin('get_all_databases', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_alter_database {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_alter_database_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_alter_database_result();
    eval {
      $self->{handler}->alter_database($args->dbname, $args->db);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::MetaException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::NoSuchObjectException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('alter_database', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_type {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_type_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_type_result();
    eval {
      $result->{success} = $self->{handler}->get_type($args->name);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::MetaException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::NoSuchObjectException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('get_type', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_create_type {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_create_type_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_create_type_result();
    eval {
      $result->{success} = $self->{handler}->create_type($args->type);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::AlreadyExistsException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::InvalidObjectException') ){ 
      $result->{o2} = $@;
        }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::MetaException') ){ 
      $result->{o3} = $@;
    }
    $output->writeMessageBegin('create_type', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_drop_type {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_drop_type_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_drop_type_result();
    eval {
      $result->{success} = $self->{handler}->drop_type($args->type);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::MetaException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::NoSuchObjectException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('drop_type', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_type_all {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_type_all_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_type_all_result();
    eval {
      $result->{success} = $self->{handler}->get_type_all($args->name);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::MetaException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('get_type_all', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_fields {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_fields_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_fields_result();
    eval {
      $result->{success} = $self->{handler}->get_fields($args->db_name, $args->table_name);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::MetaException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::UnknownTableException') ){ 
      $result->{o2} = $@;
        }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::UnknownDBException') ){ 
      $result->{o3} = $@;
    }
    $output->writeMessageBegin('get_fields', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_schema {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_schema_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_schema_result();
    eval {
      $result->{success} = $self->{handler}->get_schema($args->db_name, $args->table_name);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::MetaException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::UnknownTableException') ){ 
      $result->{o2} = $@;
        }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::UnknownDBException') ){ 
      $result->{o3} = $@;
    }
    $output->writeMessageBegin('get_schema', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_create_table {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_create_table_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_create_table_result();
    eval {
      $self->{handler}->create_table($args->tbl);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::AlreadyExistsException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::InvalidObjectException') ){ 
      $result->{o2} = $@;
        }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::MetaException') ){ 
      $result->{o3} = $@;
        }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::NoSuchObjectException') ){ 
      $result->{o4} = $@;
    }
    $output->writeMessageBegin('create_table', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_drop_table {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_drop_table_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_drop_table_result();
    eval {
      $self->{handler}->drop_table($args->dbname, $args->name, $args->deleteData);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::NoSuchObjectException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::MetaException') ){ 
      $result->{o3} = $@;
    }
    $output->writeMessageBegin('drop_table', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_tables {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_tables_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_tables_result();
    eval {
      $result->{success} = $self->{handler}->get_tables($args->db_name, $args->pattern);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::MetaException') ){ 
      $result->{o1} = $@;
    }
    $output->writeMessageBegin('get_tables', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_all_tables {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_all_tables_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_all_tables_result();
    eval {
      $result->{success} = $self->{handler}->get_all_tables($args->db_name);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::MetaException') ){ 
      $result->{o1} = $@;
    }
    $output->writeMessageBegin('get_all_tables', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_table {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_table_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_table_result();
    eval {
      $result->{success} = $self->{handler}->get_table($args->dbname, $args->tbl_name);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::MetaException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::NoSuchObjectException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('get_table', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_alter_table {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_alter_table_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_alter_table_result();
    eval {
      $self->{handler}->alter_table($args->dbname, $args->tbl_name, $args->new_tbl);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::InvalidOperationException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::MetaException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('alter_table', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_add_partition {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_add_partition_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_add_partition_result();
    eval {
      $result->{success} = $self->{handler}->add_partition($args->new_part);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::InvalidObjectException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::AlreadyExistsException') ){ 
      $result->{o2} = $@;
        }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::MetaException') ){ 
      $result->{o3} = $@;
    }
    $output->writeMessageBegin('add_partition', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_append_partition {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_append_partition_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_append_partition_result();
    eval {
      $result->{success} = $self->{handler}->append_partition($args->db_name, $args->tbl_name, $args->part_vals);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::InvalidObjectException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::AlreadyExistsException') ){ 
      $result->{o2} = $@;
        }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::MetaException') ){ 
      $result->{o3} = $@;
    }
    $output->writeMessageBegin('append_partition', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_append_partition_by_name {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_append_partition_by_name_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_append_partition_by_name_result();
    eval {
      $result->{success} = $self->{handler}->append_partition_by_name($args->db_name, $args->tbl_name, $args->part_name);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::InvalidObjectException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::AlreadyExistsException') ){ 
      $result->{o2} = $@;
        }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::MetaException') ){ 
      $result->{o3} = $@;
    }
    $output->writeMessageBegin('append_partition_by_name', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_drop_partition {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_drop_partition_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_drop_partition_result();
    eval {
      $result->{success} = $self->{handler}->drop_partition($args->db_name, $args->tbl_name, $args->part_vals, $args->deleteData);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::NoSuchObjectException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::MetaException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('drop_partition', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_drop_partition_by_name {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_drop_partition_by_name_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_drop_partition_by_name_result();
    eval {
      $result->{success} = $self->{handler}->drop_partition_by_name($args->db_name, $args->tbl_name, $args->part_name, $args->deleteData);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::NoSuchObjectException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::MetaException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('drop_partition_by_name', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_partition {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partition_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partition_result();
    eval {
      $result->{success} = $self->{handler}->get_partition($args->db_name, $args->tbl_name, $args->part_vals);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::MetaException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::NoSuchObjectException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('get_partition', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_partition_with_auth {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partition_with_auth_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partition_with_auth_result();
    eval {
      $result->{success} = $self->{handler}->get_partition_with_auth($args->db_name, $args->tbl_name, $args->part_vals, $args->user_name, $args->group_names);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::MetaException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::NoSuchObjectException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('get_partition_with_auth', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_partition_by_name {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partition_by_name_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partition_by_name_result();
    eval {
      $result->{success} = $self->{handler}->get_partition_by_name($args->db_name, $args->tbl_name, $args->part_name);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::MetaException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::NoSuchObjectException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('get_partition_by_name', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_partitions {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partitions_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partitions_result();
    eval {
      $result->{success} = $self->{handler}->get_partitions($args->db_name, $args->tbl_name, $args->max_parts);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::NoSuchObjectException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::MetaException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('get_partitions', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_partitions_with_auth {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partitions_with_auth_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partitions_with_auth_result();
    eval {
      $result->{success} = $self->{handler}->get_partitions_with_auth($args->db_name, $args->tbl_name, $args->max_parts, $args->user_name, $args->group_names);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::NoSuchObjectException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::MetaException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('get_partitions_with_auth', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_partition_names {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partition_names_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partition_names_result();
    eval {
      $result->{success} = $self->{handler}->get_partition_names($args->db_name, $args->tbl_name, $args->max_parts);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::MetaException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('get_partition_names', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_partitions_ps {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partitions_ps_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partitions_ps_result();
    eval {
      $result->{success} = $self->{handler}->get_partitions_ps($args->db_name, $args->tbl_name, $args->part_vals, $args->max_parts);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::MetaException') ){ 
      $result->{o1} = $@;
    }
    $output->writeMessageBegin('get_partitions_ps', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_partitions_ps_with_auth {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partitions_ps_with_auth_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partitions_ps_with_auth_result();
    eval {
      $result->{success} = $self->{handler}->get_partitions_ps_with_auth($args->db_name, $args->tbl_name, $args->part_vals, $args->max_parts, $args->user_name, $args->group_names);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::NoSuchObjectException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::MetaException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('get_partitions_ps_with_auth', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_partition_names_ps {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partition_names_ps_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partition_names_ps_result();
    eval {
      $result->{success} = $self->{handler}->get_partition_names_ps($args->db_name, $args->tbl_name, $args->part_vals, $args->max_parts);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::MetaException') ){ 
      $result->{o1} = $@;
    }
    $output->writeMessageBegin('get_partition_names_ps', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_partitions_by_filter {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partitions_by_filter_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_partitions_by_filter_result();
    eval {
      $result->{success} = $self->{handler}->get_partitions_by_filter($args->db_name, $args->tbl_name, $args->filter, $args->max_parts);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::MetaException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::NoSuchObjectException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('get_partitions_by_filter', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_alter_partition {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_alter_partition_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_alter_partition_result();
    eval {
      $self->{handler}->alter_partition($args->db_name, $args->tbl_name, $args->new_part);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::InvalidOperationException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::MetaException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('alter_partition', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_config_value {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_config_value_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_config_value_result();
    eval {
      $result->{success} = $self->{handler}->get_config_value($args->name, $args->defaultValue);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::ConfigValSecurityException') ){ 
      $result->{o1} = $@;
    }
    $output->writeMessageBegin('get_config_value', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_partition_name_to_vals {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_partition_name_to_vals_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_partition_name_to_vals_result();
    eval {
      $result->{success} = $self->{handler}->partition_name_to_vals($args->part_name);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::MetaException') ){ 
      $result->{o1} = $@;
    }
    $output->writeMessageBegin('partition_name_to_vals', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_partition_name_to_spec {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_partition_name_to_spec_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_partition_name_to_spec_result();
    eval {
      $result->{success} = $self->{handler}->partition_name_to_spec($args->part_name);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::MetaException') ){ 
      $result->{o1} = $@;
    }
    $output->writeMessageBegin('partition_name_to_spec', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_add_index {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_add_index_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_add_index_result();
    eval {
      $result->{success} = $self->{handler}->add_index($args->new_index, $args->index_table);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::InvalidObjectException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::AlreadyExistsException') ){ 
      $result->{o2} = $@;
        }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::MetaException') ){ 
      $result->{o3} = $@;
    }
    $output->writeMessageBegin('add_index', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_alter_index {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_alter_index_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_alter_index_result();
    eval {
      $self->{handler}->alter_index($args->dbname, $args->base_tbl_name, $args->idx_name, $args->new_idx);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::InvalidOperationException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::MetaException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('alter_index', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_drop_index_by_name {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_drop_index_by_name_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_drop_index_by_name_result();
    eval {
      $result->{success} = $self->{handler}->drop_index_by_name($args->db_name, $args->tbl_name, $args->index_name, $args->deleteData);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::NoSuchObjectException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::MetaException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('drop_index_by_name', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_index_by_name {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_index_by_name_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_index_by_name_result();
    eval {
      $result->{success} = $self->{handler}->get_index_by_name($args->db_name, $args->tbl_name, $args->index_name);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::MetaException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::NoSuchObjectException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('get_index_by_name', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_indexes {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_indexes_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_indexes_result();
    eval {
      $result->{success} = $self->{handler}->get_indexes($args->db_name, $args->tbl_name, $args->max_indexes);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::NoSuchObjectException') ){ 
      $result->{o1} = $@;
        }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::MetaException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('get_indexes', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_index_names {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_index_names_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_index_names_result();
    eval {
      $result->{success} = $self->{handler}->get_index_names($args->db_name, $args->tbl_name, $args->max_indexes);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::MetaException') ){ 
      $result->{o2} = $@;
    }
    $output->writeMessageBegin('get_index_names', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_create_role {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_create_role_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_create_role_result();
    eval {
      $result->{success} = $self->{handler}->create_role($args->role);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::MetaException') ){ 
      $result->{o1} = $@;
    }
    $output->writeMessageBegin('create_role', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_drop_role {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_drop_role_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_drop_role_result();
    eval {
      $result->{success} = $self->{handler}->drop_role($args->role_name);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::MetaException') ){ 
      $result->{o1} = $@;
    }
    $output->writeMessageBegin('drop_role', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_role_names {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_role_names_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_role_names_result();
    eval {
      $result->{success} = $self->{handler}->get_role_names();
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::MetaException') ){ 
      $result->{o1} = $@;
    }
    $output->writeMessageBegin('get_role_names', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_grant_role {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_grant_role_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_grant_role_result();
    eval {
      $result->{success} = $self->{handler}->grant_role($args->role_name, $args->principal_name, $args->principal_type, $args->grantor, $args->grantorType, $args->grant_option);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::MetaException') ){ 
      $result->{o1} = $@;
    }
    $output->writeMessageBegin('grant_role', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_revoke_role {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_revoke_role_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_revoke_role_result();
    eval {
      $result->{success} = $self->{handler}->revoke_role($args->role_name, $args->principal_name, $args->principal_type);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::MetaException') ){ 
      $result->{o1} = $@;
    }
    $output->writeMessageBegin('revoke_role', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_list_roles {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_list_roles_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_list_roles_result();
    eval {
      $result->{success} = $self->{handler}->list_roles($args->principal_name, $args->principal_type);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::MetaException') ){ 
      $result->{o1} = $@;
    }
    $output->writeMessageBegin('list_roles', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_privilege_set {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_privilege_set_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_privilege_set_result();
    eval {
      $result->{success} = $self->{handler}->get_privilege_set($args->hiveObject, $args->user_name, $args->group_names);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::MetaException') ){ 
      $result->{o1} = $@;
    }
    $output->writeMessageBegin('get_privilege_set', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_list_privileges {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_list_privileges_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_list_privileges_result();
    eval {
      $result->{success} = $self->{handler}->list_privileges($args->principal_name, $args->principal_type, $args->hiveObject);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::MetaException') ){ 
      $result->{o1} = $@;
    }
    $output->writeMessageBegin('list_privileges', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_grant_privileges {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_grant_privileges_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_grant_privileges_result();
    eval {
      $result->{success} = $self->{handler}->grant_privileges($args->privileges);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::MetaException') ){ 
      $result->{o1} = $@;
    }
    $output->writeMessageBegin('grant_privileges', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_revoke_privileges {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_revoke_privileges_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_revoke_privileges_result();
    eval {
      $result->{success} = $self->{handler}->revoke_privileges($args->privileges);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::MetaException') ){ 
      $result->{o1} = $@;
    }
    $output->writeMessageBegin('revoke_privileges', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_delegation_token {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_delegation_token_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_delegation_token_result();
    eval {
      $result->{success} = $self->{handler}->get_delegation_token($args->renewer_kerberos_principal_name);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::MetaException') ){ 
      $result->{o1} = $@;
    }
    $output->writeMessageBegin('get_delegation_token', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_delegation_token_with_signature {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_delegation_token_with_signature_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_get_delegation_token_with_signature_result();
    eval {
      $result->{success} = $self->{handler}->get_delegation_token_with_signature($args->renewer_kerberos_principal_name, $args->token_signature);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::MetaException') ){ 
      $result->{o1} = $@;
    }
    $output->writeMessageBegin('get_delegation_token_with_signature', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_renew_delegation_token {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_renew_delegation_token_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_renew_delegation_token_result();
    eval {
      $result->{success} = $self->{handler}->renew_delegation_token($args->token_str_form);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::MetaException') ){ 
      $result->{o1} = $@;
    }
    $output->writeMessageBegin('renew_delegation_token', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_cancel_delegation_token {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_cancel_delegation_token_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HiveClient::Metastore::ThriftHiveMetastore_cancel_delegation_token_result();
    eval {
      $self->{handler}->cancel_delegation_token($args->token_str_form);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HiveClient::Metastore::MetaException') ){ 
      $result->{o1} = $@;
    }
    $output->writeMessageBegin('cancel_delegation_token', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

1;
