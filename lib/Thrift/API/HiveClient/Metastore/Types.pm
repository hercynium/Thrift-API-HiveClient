#
# Autogenerated by Thrift Compiler (0.8.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

package
   Thrift::API::HiveClient::Metastore::HiveObjectType;
use constant GLOBAL => 1;
use constant DATABASE => 2;
use constant TABLE => 3;
use constant PARTITION => 4;
use constant COLUMN => 5;
package
   Thrift::API::HiveClient::Metastore::PrincipalType;
use constant USER => 1;
use constant ROLE => 2;
use constant GROUP => 3;
package
   Thrift::API::HiveClient::Metastore::Version;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::Version->mk_accessors( qw( version comments ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{version} = undef;
  $self->{comments} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{version}) {
      $self->{version} = $vals->{version};
    }
    if (defined $vals->{comments}) {
      $self->{comments} = $vals->{comments};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Version';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{version});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{comments});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Version');
  if (defined $self->{version}) {
    $xfer += $output->writeFieldBegin('version', TType::STRING, 1);
    $xfer += $output->writeString($self->{version});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{comments}) {
    $xfer += $output->writeFieldBegin('comments', TType::STRING, 2);
    $xfer += $output->writeString($self->{comments});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::FieldSchema;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::FieldSchema->mk_accessors( qw( name type comment ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{type} = undef;
  $self->{comment} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{type}) {
      $self->{type} = $vals->{type};
    }
    if (defined $vals->{comment}) {
      $self->{comment} = $vals->{comment};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'FieldSchema';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{type});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{comment});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('FieldSchema');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{type}) {
    $xfer += $output->writeFieldBegin('type', TType::STRING, 2);
    $xfer += $output->writeString($self->{type});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{comment}) {
    $xfer += $output->writeFieldBegin('comment', TType::STRING, 3);
    $xfer += $output->writeString($self->{comment});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::Type;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::Type->mk_accessors( qw( name type1 type2 fields ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{type1} = undef;
  $self->{type2} = undef;
  $self->{fields} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{type1}) {
      $self->{type1} = $vals->{type1};
    }
    if (defined $vals->{type2}) {
      $self->{type2} = $vals->{type2};
    }
    if (defined $vals->{fields}) {
      $self->{fields} = $vals->{fields};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Type';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{type1});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{type2});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size0 = 0;
          $self->{fields} = [];
          my $_etype3 = 0;
          $xfer += $input->readListBegin(\$_etype3, \$_size0);
          for (my $_i4 = 0; $_i4 < $_size0; ++$_i4)
          {
            my $elem5 = undef;
            $elem5 = new Thrift::API::HiveClient::Metastore::FieldSchema();
            $xfer += $elem5->read($input);
            push(@{$self->{fields}},$elem5);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Type');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{type1}) {
    $xfer += $output->writeFieldBegin('type1', TType::STRING, 2);
    $xfer += $output->writeString($self->{type1});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{type2}) {
    $xfer += $output->writeFieldBegin('type2', TType::STRING, 3);
    $xfer += $output->writeString($self->{type2});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{fields}) {
    $xfer += $output->writeFieldBegin('fields', TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{fields}}));
      {
        foreach my $iter6 (@{$self->{fields}}) 
        {
          $xfer += ${iter6}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::HiveObjectRef;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::HiveObjectRef->mk_accessors( qw( objectType dbName objectName partValues columnName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{objectType} = undef;
  $self->{dbName} = undef;
  $self->{objectName} = undef;
  $self->{partValues} = undef;
  $self->{columnName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{objectType}) {
      $self->{objectType} = $vals->{objectType};
    }
    if (defined $vals->{dbName}) {
      $self->{dbName} = $vals->{dbName};
    }
    if (defined $vals->{objectName}) {
      $self->{objectName} = $vals->{objectName};
    }
    if (defined $vals->{partValues}) {
      $self->{partValues} = $vals->{partValues};
    }
    if (defined $vals->{columnName}) {
      $self->{columnName} = $vals->{columnName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'HiveObjectRef';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{objectType});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{dbName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{objectName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size7 = 0;
          $self->{partValues} = [];
          my $_etype10 = 0;
          $xfer += $input->readListBegin(\$_etype10, \$_size7);
          for (my $_i11 = 0; $_i11 < $_size7; ++$_i11)
          {
            my $elem12 = undef;
            $xfer += $input->readString(\$elem12);
            push(@{$self->{partValues}},$elem12);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{columnName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('HiveObjectRef');
  if (defined $self->{objectType}) {
    $xfer += $output->writeFieldBegin('objectType', TType::I32, 1);
    $xfer += $output->writeI32($self->{objectType});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{dbName}) {
    $xfer += $output->writeFieldBegin('dbName', TType::STRING, 2);
    $xfer += $output->writeString($self->{dbName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{objectName}) {
    $xfer += $output->writeFieldBegin('objectName', TType::STRING, 3);
    $xfer += $output->writeString($self->{objectName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{partValues}) {
    $xfer += $output->writeFieldBegin('partValues', TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{partValues}}));
      {
        foreach my $iter13 (@{$self->{partValues}}) 
        {
          $xfer += $output->writeString($iter13);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnName}) {
    $xfer += $output->writeFieldBegin('columnName', TType::STRING, 5);
    $xfer += $output->writeString($self->{columnName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::PrivilegeGrantInfo;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::PrivilegeGrantInfo->mk_accessors( qw( privilege createTime grantor grantorType grantOption ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{privilege} = undef;
  $self->{createTime} = undef;
  $self->{grantor} = undef;
  $self->{grantorType} = undef;
  $self->{grantOption} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{privilege}) {
      $self->{privilege} = $vals->{privilege};
    }
    if (defined $vals->{createTime}) {
      $self->{createTime} = $vals->{createTime};
    }
    if (defined $vals->{grantor}) {
      $self->{grantor} = $vals->{grantor};
    }
    if (defined $vals->{grantorType}) {
      $self->{grantorType} = $vals->{grantorType};
    }
    if (defined $vals->{grantOption}) {
      $self->{grantOption} = $vals->{grantOption};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'PrivilegeGrantInfo';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{privilege});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{createTime});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{grantor});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{grantorType});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{grantOption});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('PrivilegeGrantInfo');
  if (defined $self->{privilege}) {
    $xfer += $output->writeFieldBegin('privilege', TType::STRING, 1);
    $xfer += $output->writeString($self->{privilege});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{createTime}) {
    $xfer += $output->writeFieldBegin('createTime', TType::I32, 2);
    $xfer += $output->writeI32($self->{createTime});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{grantor}) {
    $xfer += $output->writeFieldBegin('grantor', TType::STRING, 3);
    $xfer += $output->writeString($self->{grantor});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{grantorType}) {
    $xfer += $output->writeFieldBegin('grantorType', TType::I32, 4);
    $xfer += $output->writeI32($self->{grantorType});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{grantOption}) {
    $xfer += $output->writeFieldBegin('grantOption', TType::BOOL, 5);
    $xfer += $output->writeBool($self->{grantOption});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::HiveObjectPrivilege;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::HiveObjectPrivilege->mk_accessors( qw( hiveObject principalName principalType grantInfo ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{hiveObject} = undef;
  $self->{principalName} = undef;
  $self->{principalType} = undef;
  $self->{grantInfo} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{hiveObject}) {
      $self->{hiveObject} = $vals->{hiveObject};
    }
    if (defined $vals->{principalName}) {
      $self->{principalName} = $vals->{principalName};
    }
    if (defined $vals->{principalType}) {
      $self->{principalType} = $vals->{principalType};
    }
    if (defined $vals->{grantInfo}) {
      $self->{grantInfo} = $vals->{grantInfo};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'HiveObjectPrivilege';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{hiveObject} = new Thrift::API::HiveClient::Metastore::HiveObjectRef();
        $xfer += $self->{hiveObject}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{principalName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{principalType});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{grantInfo} = new Thrift::API::HiveClient::Metastore::PrivilegeGrantInfo();
        $xfer += $self->{grantInfo}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('HiveObjectPrivilege');
  if (defined $self->{hiveObject}) {
    $xfer += $output->writeFieldBegin('hiveObject', TType::STRUCT, 1);
    $xfer += $self->{hiveObject}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{principalName}) {
    $xfer += $output->writeFieldBegin('principalName', TType::STRING, 2);
    $xfer += $output->writeString($self->{principalName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{principalType}) {
    $xfer += $output->writeFieldBegin('principalType', TType::I32, 3);
    $xfer += $output->writeI32($self->{principalType});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{grantInfo}) {
    $xfer += $output->writeFieldBegin('grantInfo', TType::STRUCT, 4);
    $xfer += $self->{grantInfo}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::PrivilegeBag;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::PrivilegeBag->mk_accessors( qw( privileges ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{privileges} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{privileges}) {
      $self->{privileges} = $vals->{privileges};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'PrivilegeBag';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size14 = 0;
          $self->{privileges} = [];
          my $_etype17 = 0;
          $xfer += $input->readListBegin(\$_etype17, \$_size14);
          for (my $_i18 = 0; $_i18 < $_size14; ++$_i18)
          {
            my $elem19 = undef;
            $elem19 = new Thrift::API::HiveClient::Metastore::HiveObjectPrivilege();
            $xfer += $elem19->read($input);
            push(@{$self->{privileges}},$elem19);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('PrivilegeBag');
  if (defined $self->{privileges}) {
    $xfer += $output->writeFieldBegin('privileges', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{privileges}}));
      {
        foreach my $iter20 (@{$self->{privileges}}) 
        {
          $xfer += ${iter20}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::PrincipalPrivilegeSet;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::PrincipalPrivilegeSet->mk_accessors( qw( userPrivileges groupPrivileges rolePrivileges ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{userPrivileges} = undef;
  $self->{groupPrivileges} = undef;
  $self->{rolePrivileges} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{userPrivileges}) {
      $self->{userPrivileges} = $vals->{userPrivileges};
    }
    if (defined $vals->{groupPrivileges}) {
      $self->{groupPrivileges} = $vals->{groupPrivileges};
    }
    if (defined $vals->{rolePrivileges}) {
      $self->{rolePrivileges} = $vals->{rolePrivileges};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'PrincipalPrivilegeSet';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size21 = 0;
          $self->{userPrivileges} = {};
          my $_ktype22 = 0;
          my $_vtype23 = 0;
          $xfer += $input->readMapBegin(\$_ktype22, \$_vtype23, \$_size21);
          for (my $_i25 = 0; $_i25 < $_size21; ++$_i25)
          {
            my $key26 = '';
            my $val27 = [];
            $xfer += $input->readString(\$key26);
            {
              my $_size28 = 0;
              $val27 = [];
              my $_etype31 = 0;
              $xfer += $input->readListBegin(\$_etype31, \$_size28);
              for (my $_i32 = 0; $_i32 < $_size28; ++$_i32)
              {
                my $elem33 = undef;
                $elem33 = new Thrift::API::HiveClient::Metastore::PrivilegeGrantInfo();
                $xfer += $elem33->read($input);
                push(@{$val27},$elem33);
              }
              $xfer += $input->readListEnd();
            }
            $self->{userPrivileges}->{$key26} = $val27;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size34 = 0;
          $self->{groupPrivileges} = {};
          my $_ktype35 = 0;
          my $_vtype36 = 0;
          $xfer += $input->readMapBegin(\$_ktype35, \$_vtype36, \$_size34);
          for (my $_i38 = 0; $_i38 < $_size34; ++$_i38)
          {
            my $key39 = '';
            my $val40 = [];
            $xfer += $input->readString(\$key39);
            {
              my $_size41 = 0;
              $val40 = [];
              my $_etype44 = 0;
              $xfer += $input->readListBegin(\$_etype44, \$_size41);
              for (my $_i45 = 0; $_i45 < $_size41; ++$_i45)
              {
                my $elem46 = undef;
                $elem46 = new Thrift::API::HiveClient::Metastore::PrivilegeGrantInfo();
                $xfer += $elem46->read($input);
                push(@{$val40},$elem46);
              }
              $xfer += $input->readListEnd();
            }
            $self->{groupPrivileges}->{$key39} = $val40;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size47 = 0;
          $self->{rolePrivileges} = {};
          my $_ktype48 = 0;
          my $_vtype49 = 0;
          $xfer += $input->readMapBegin(\$_ktype48, \$_vtype49, \$_size47);
          for (my $_i51 = 0; $_i51 < $_size47; ++$_i51)
          {
            my $key52 = '';
            my $val53 = [];
            $xfer += $input->readString(\$key52);
            {
              my $_size54 = 0;
              $val53 = [];
              my $_etype57 = 0;
              $xfer += $input->readListBegin(\$_etype57, \$_size54);
              for (my $_i58 = 0; $_i58 < $_size54; ++$_i58)
              {
                my $elem59 = undef;
                $elem59 = new Thrift::API::HiveClient::Metastore::PrivilegeGrantInfo();
                $xfer += $elem59->read($input);
                push(@{$val53},$elem59);
              }
              $xfer += $input->readListEnd();
            }
            $self->{rolePrivileges}->{$key52} = $val53;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('PrincipalPrivilegeSet');
  if (defined $self->{userPrivileges}) {
    $xfer += $output->writeFieldBegin('userPrivileges', TType::MAP, 1);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::LIST, scalar(keys %{$self->{userPrivileges}}));
      {
        while( my ($kiter60,$viter61) = each %{$self->{userPrivileges}}) 
        {
          $xfer += $output->writeString($kiter60);
          {
            $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{${viter61}}));
            {
              foreach my $iter62 (@{${viter61}}) 
              {
                $xfer += ${iter62}->write($output);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{groupPrivileges}) {
    $xfer += $output->writeFieldBegin('groupPrivileges', TType::MAP, 2);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::LIST, scalar(keys %{$self->{groupPrivileges}}));
      {
        while( my ($kiter63,$viter64) = each %{$self->{groupPrivileges}}) 
        {
          $xfer += $output->writeString($kiter63);
          {
            $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{${viter64}}));
            {
              foreach my $iter65 (@{${viter64}}) 
              {
                $xfer += ${iter65}->write($output);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rolePrivileges}) {
    $xfer += $output->writeFieldBegin('rolePrivileges', TType::MAP, 3);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::LIST, scalar(keys %{$self->{rolePrivileges}}));
      {
        while( my ($kiter66,$viter67) = each %{$self->{rolePrivileges}}) 
        {
          $xfer += $output->writeString($kiter66);
          {
            $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{${viter67}}));
            {
              foreach my $iter68 (@{${viter67}}) 
              {
                $xfer += ${iter68}->write($output);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::Role;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::Role->mk_accessors( qw( roleName createTime ownerName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{roleName} = undef;
  $self->{createTime} = undef;
  $self->{ownerName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{roleName}) {
      $self->{roleName} = $vals->{roleName};
    }
    if (defined $vals->{createTime}) {
      $self->{createTime} = $vals->{createTime};
    }
    if (defined $vals->{ownerName}) {
      $self->{ownerName} = $vals->{ownerName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Role';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{roleName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{createTime});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{ownerName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Role');
  if (defined $self->{roleName}) {
    $xfer += $output->writeFieldBegin('roleName', TType::STRING, 1);
    $xfer += $output->writeString($self->{roleName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{createTime}) {
    $xfer += $output->writeFieldBegin('createTime', TType::I32, 2);
    $xfer += $output->writeI32($self->{createTime});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ownerName}) {
    $xfer += $output->writeFieldBegin('ownerName', TType::STRING, 3);
    $xfer += $output->writeString($self->{ownerName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::Database;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::Database->mk_accessors( qw( name description locationUri parameters privileges ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{description} = undef;
  $self->{locationUri} = undef;
  $self->{parameters} = undef;
  $self->{privileges} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{description}) {
      $self->{description} = $vals->{description};
    }
    if (defined $vals->{locationUri}) {
      $self->{locationUri} = $vals->{locationUri};
    }
    if (defined $vals->{parameters}) {
      $self->{parameters} = $vals->{parameters};
    }
    if (defined $vals->{privileges}) {
      $self->{privileges} = $vals->{privileges};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Database';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{description});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{locationUri});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size69 = 0;
          $self->{parameters} = {};
          my $_ktype70 = 0;
          my $_vtype71 = 0;
          $xfer += $input->readMapBegin(\$_ktype70, \$_vtype71, \$_size69);
          for (my $_i73 = 0; $_i73 < $_size69; ++$_i73)
          {
            my $key74 = '';
            my $val75 = '';
            $xfer += $input->readString(\$key74);
            $xfer += $input->readString(\$val75);
            $self->{parameters}->{$key74} = $val75;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{privileges} = new Thrift::API::HiveClient::Metastore::PrincipalPrivilegeSet();
        $xfer += $self->{privileges}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Database');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{description}) {
    $xfer += $output->writeFieldBegin('description', TType::STRING, 2);
    $xfer += $output->writeString($self->{description});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{locationUri}) {
    $xfer += $output->writeFieldBegin('locationUri', TType::STRING, 3);
    $xfer += $output->writeString($self->{locationUri});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{parameters}) {
    $xfer += $output->writeFieldBegin('parameters', TType::MAP, 4);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{parameters}}));
      {
        while( my ($kiter76,$viter77) = each %{$self->{parameters}}) 
        {
          $xfer += $output->writeString($kiter76);
          $xfer += $output->writeString($viter77);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{privileges}) {
    $xfer += $output->writeFieldBegin('privileges', TType::STRUCT, 5);
    $xfer += $self->{privileges}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::SerDeInfo;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::SerDeInfo->mk_accessors( qw( name serializationLib parameters ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{serializationLib} = undef;
  $self->{parameters} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{serializationLib}) {
      $self->{serializationLib} = $vals->{serializationLib};
    }
    if (defined $vals->{parameters}) {
      $self->{parameters} = $vals->{parameters};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'SerDeInfo';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{serializationLib});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size78 = 0;
          $self->{parameters} = {};
          my $_ktype79 = 0;
          my $_vtype80 = 0;
          $xfer += $input->readMapBegin(\$_ktype79, \$_vtype80, \$_size78);
          for (my $_i82 = 0; $_i82 < $_size78; ++$_i82)
          {
            my $key83 = '';
            my $val84 = '';
            $xfer += $input->readString(\$key83);
            $xfer += $input->readString(\$val84);
            $self->{parameters}->{$key83} = $val84;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('SerDeInfo');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{serializationLib}) {
    $xfer += $output->writeFieldBegin('serializationLib', TType::STRING, 2);
    $xfer += $output->writeString($self->{serializationLib});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{parameters}) {
    $xfer += $output->writeFieldBegin('parameters', TType::MAP, 3);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{parameters}}));
      {
        while( my ($kiter85,$viter86) = each %{$self->{parameters}}) 
        {
          $xfer += $output->writeString($kiter85);
          $xfer += $output->writeString($viter86);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::Order;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::Order->mk_accessors( qw( col order ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{col} = undef;
  $self->{order} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{col}) {
      $self->{col} = $vals->{col};
    }
    if (defined $vals->{order}) {
      $self->{order} = $vals->{order};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Order';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{col});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{order});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Order');
  if (defined $self->{col}) {
    $xfer += $output->writeFieldBegin('col', TType::STRING, 1);
    $xfer += $output->writeString($self->{col});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{order}) {
    $xfer += $output->writeFieldBegin('order', TType::I32, 2);
    $xfer += $output->writeI32($self->{order});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::StorageDescriptor;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::StorageDescriptor->mk_accessors( qw( cols location inputFormat outputFormat compressed numBuckets serdeInfo bucketCols sortCols parameters ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{cols} = undef;
  $self->{location} = undef;
  $self->{inputFormat} = undef;
  $self->{outputFormat} = undef;
  $self->{compressed} = undef;
  $self->{numBuckets} = undef;
  $self->{serdeInfo} = undef;
  $self->{bucketCols} = undef;
  $self->{sortCols} = undef;
  $self->{parameters} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{cols}) {
      $self->{cols} = $vals->{cols};
    }
    if (defined $vals->{location}) {
      $self->{location} = $vals->{location};
    }
    if (defined $vals->{inputFormat}) {
      $self->{inputFormat} = $vals->{inputFormat};
    }
    if (defined $vals->{outputFormat}) {
      $self->{outputFormat} = $vals->{outputFormat};
    }
    if (defined $vals->{compressed}) {
      $self->{compressed} = $vals->{compressed};
    }
    if (defined $vals->{numBuckets}) {
      $self->{numBuckets} = $vals->{numBuckets};
    }
    if (defined $vals->{serdeInfo}) {
      $self->{serdeInfo} = $vals->{serdeInfo};
    }
    if (defined $vals->{bucketCols}) {
      $self->{bucketCols} = $vals->{bucketCols};
    }
    if (defined $vals->{sortCols}) {
      $self->{sortCols} = $vals->{sortCols};
    }
    if (defined $vals->{parameters}) {
      $self->{parameters} = $vals->{parameters};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'StorageDescriptor';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size87 = 0;
          $self->{cols} = [];
          my $_etype90 = 0;
          $xfer += $input->readListBegin(\$_etype90, \$_size87);
          for (my $_i91 = 0; $_i91 < $_size87; ++$_i91)
          {
            my $elem92 = undef;
            $elem92 = new Thrift::API::HiveClient::Metastore::FieldSchema();
            $xfer += $elem92->read($input);
            push(@{$self->{cols}},$elem92);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{location});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{inputFormat});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{outputFormat});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{compressed});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{numBuckets});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{serdeInfo} = new Thrift::API::HiveClient::Metastore::SerDeInfo();
        $xfer += $self->{serdeInfo}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size93 = 0;
          $self->{bucketCols} = [];
          my $_etype96 = 0;
          $xfer += $input->readListBegin(\$_etype96, \$_size93);
          for (my $_i97 = 0; $_i97 < $_size93; ++$_i97)
          {
            my $elem98 = undef;
            $xfer += $input->readString(\$elem98);
            push(@{$self->{bucketCols}},$elem98);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^9$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size99 = 0;
          $self->{sortCols} = [];
          my $_etype102 = 0;
          $xfer += $input->readListBegin(\$_etype102, \$_size99);
          for (my $_i103 = 0; $_i103 < $_size99; ++$_i103)
          {
            my $elem104 = undef;
            $elem104 = new Thrift::API::HiveClient::Metastore::Order();
            $xfer += $elem104->read($input);
            push(@{$self->{sortCols}},$elem104);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^10$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size105 = 0;
          $self->{parameters} = {};
          my $_ktype106 = 0;
          my $_vtype107 = 0;
          $xfer += $input->readMapBegin(\$_ktype106, \$_vtype107, \$_size105);
          for (my $_i109 = 0; $_i109 < $_size105; ++$_i109)
          {
            my $key110 = '';
            my $val111 = '';
            $xfer += $input->readString(\$key110);
            $xfer += $input->readString(\$val111);
            $self->{parameters}->{$key110} = $val111;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('StorageDescriptor');
  if (defined $self->{cols}) {
    $xfer += $output->writeFieldBegin('cols', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{cols}}));
      {
        foreach my $iter112 (@{$self->{cols}}) 
        {
          $xfer += ${iter112}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{location}) {
    $xfer += $output->writeFieldBegin('location', TType::STRING, 2);
    $xfer += $output->writeString($self->{location});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{inputFormat}) {
    $xfer += $output->writeFieldBegin('inputFormat', TType::STRING, 3);
    $xfer += $output->writeString($self->{inputFormat});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{outputFormat}) {
    $xfer += $output->writeFieldBegin('outputFormat', TType::STRING, 4);
    $xfer += $output->writeString($self->{outputFormat});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{compressed}) {
    $xfer += $output->writeFieldBegin('compressed', TType::BOOL, 5);
    $xfer += $output->writeBool($self->{compressed});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{numBuckets}) {
    $xfer += $output->writeFieldBegin('numBuckets', TType::I32, 6);
    $xfer += $output->writeI32($self->{numBuckets});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{serdeInfo}) {
    $xfer += $output->writeFieldBegin('serdeInfo', TType::STRUCT, 7);
    $xfer += $self->{serdeInfo}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{bucketCols}) {
    $xfer += $output->writeFieldBegin('bucketCols', TType::LIST, 8);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{bucketCols}}));
      {
        foreach my $iter113 (@{$self->{bucketCols}}) 
        {
          $xfer += $output->writeString($iter113);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sortCols}) {
    $xfer += $output->writeFieldBegin('sortCols', TType::LIST, 9);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{sortCols}}));
      {
        foreach my $iter114 (@{$self->{sortCols}}) 
        {
          $xfer += ${iter114}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{parameters}) {
    $xfer += $output->writeFieldBegin('parameters', TType::MAP, 10);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{parameters}}));
      {
        while( my ($kiter115,$viter116) = each %{$self->{parameters}}) 
        {
          $xfer += $output->writeString($kiter115);
          $xfer += $output->writeString($viter116);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::Table;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::Table->mk_accessors( qw( tableName dbName owner createTime lastAccessTime retention sd partitionKeys parameters viewOriginalText viewExpandedText tableType privileges ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{dbName} = undef;
  $self->{owner} = undef;
  $self->{createTime} = undef;
  $self->{lastAccessTime} = undef;
  $self->{retention} = undef;
  $self->{sd} = undef;
  $self->{partitionKeys} = undef;
  $self->{parameters} = undef;
  $self->{viewOriginalText} = undef;
  $self->{viewExpandedText} = undef;
  $self->{tableType} = undef;
  $self->{privileges} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{dbName}) {
      $self->{dbName} = $vals->{dbName};
    }
    if (defined $vals->{owner}) {
      $self->{owner} = $vals->{owner};
    }
    if (defined $vals->{createTime}) {
      $self->{createTime} = $vals->{createTime};
    }
    if (defined $vals->{lastAccessTime}) {
      $self->{lastAccessTime} = $vals->{lastAccessTime};
    }
    if (defined $vals->{retention}) {
      $self->{retention} = $vals->{retention};
    }
    if (defined $vals->{sd}) {
      $self->{sd} = $vals->{sd};
    }
    if (defined $vals->{partitionKeys}) {
      $self->{partitionKeys} = $vals->{partitionKeys};
    }
    if (defined $vals->{parameters}) {
      $self->{parameters} = $vals->{parameters};
    }
    if (defined $vals->{viewOriginalText}) {
      $self->{viewOriginalText} = $vals->{viewOriginalText};
    }
    if (defined $vals->{viewExpandedText}) {
      $self->{viewExpandedText} = $vals->{viewExpandedText};
    }
    if (defined $vals->{tableType}) {
      $self->{tableType} = $vals->{tableType};
    }
    if (defined $vals->{privileges}) {
      $self->{privileges} = $vals->{privileges};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Table';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{dbName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{owner});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{createTime});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{lastAccessTime});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{retention});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{sd} = new Thrift::API::HiveClient::Metastore::StorageDescriptor();
        $xfer += $self->{sd}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size117 = 0;
          $self->{partitionKeys} = [];
          my $_etype120 = 0;
          $xfer += $input->readListBegin(\$_etype120, \$_size117);
          for (my $_i121 = 0; $_i121 < $_size117; ++$_i121)
          {
            my $elem122 = undef;
            $elem122 = new Thrift::API::HiveClient::Metastore::FieldSchema();
            $xfer += $elem122->read($input);
            push(@{$self->{partitionKeys}},$elem122);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^9$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size123 = 0;
          $self->{parameters} = {};
          my $_ktype124 = 0;
          my $_vtype125 = 0;
          $xfer += $input->readMapBegin(\$_ktype124, \$_vtype125, \$_size123);
          for (my $_i127 = 0; $_i127 < $_size123; ++$_i127)
          {
            my $key128 = '';
            my $val129 = '';
            $xfer += $input->readString(\$key128);
            $xfer += $input->readString(\$val129);
            $self->{parameters}->{$key128} = $val129;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^10$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{viewOriginalText});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^11$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{viewExpandedText});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^12$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableType});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^13$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{privileges} = new Thrift::API::HiveClient::Metastore::PrincipalPrivilegeSet();
        $xfer += $self->{privileges}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Table');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{dbName}) {
    $xfer += $output->writeFieldBegin('dbName', TType::STRING, 2);
    $xfer += $output->writeString($self->{dbName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{owner}) {
    $xfer += $output->writeFieldBegin('owner', TType::STRING, 3);
    $xfer += $output->writeString($self->{owner});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{createTime}) {
    $xfer += $output->writeFieldBegin('createTime', TType::I32, 4);
    $xfer += $output->writeI32($self->{createTime});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{lastAccessTime}) {
    $xfer += $output->writeFieldBegin('lastAccessTime', TType::I32, 5);
    $xfer += $output->writeI32($self->{lastAccessTime});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{retention}) {
    $xfer += $output->writeFieldBegin('retention', TType::I32, 6);
    $xfer += $output->writeI32($self->{retention});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sd}) {
    $xfer += $output->writeFieldBegin('sd', TType::STRUCT, 7);
    $xfer += $self->{sd}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{partitionKeys}) {
    $xfer += $output->writeFieldBegin('partitionKeys', TType::LIST, 8);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{partitionKeys}}));
      {
        foreach my $iter130 (@{$self->{partitionKeys}}) 
        {
          $xfer += ${iter130}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{parameters}) {
    $xfer += $output->writeFieldBegin('parameters', TType::MAP, 9);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{parameters}}));
      {
        while( my ($kiter131,$viter132) = each %{$self->{parameters}}) 
        {
          $xfer += $output->writeString($kiter131);
          $xfer += $output->writeString($viter132);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{viewOriginalText}) {
    $xfer += $output->writeFieldBegin('viewOriginalText', TType::STRING, 10);
    $xfer += $output->writeString($self->{viewOriginalText});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{viewExpandedText}) {
    $xfer += $output->writeFieldBegin('viewExpandedText', TType::STRING, 11);
    $xfer += $output->writeString($self->{viewExpandedText});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tableType}) {
    $xfer += $output->writeFieldBegin('tableType', TType::STRING, 12);
    $xfer += $output->writeString($self->{tableType});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{privileges}) {
    $xfer += $output->writeFieldBegin('privileges', TType::STRUCT, 13);
    $xfer += $self->{privileges}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::Partition;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::Partition->mk_accessors( qw( values dbName tableName createTime lastAccessTime sd parameters privileges ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{values} = undef;
  $self->{dbName} = undef;
  $self->{tableName} = undef;
  $self->{createTime} = undef;
  $self->{lastAccessTime} = undef;
  $self->{sd} = undef;
  $self->{parameters} = undef;
  $self->{privileges} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{values}) {
      $self->{values} = $vals->{values};
    }
    if (defined $vals->{dbName}) {
      $self->{dbName} = $vals->{dbName};
    }
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{createTime}) {
      $self->{createTime} = $vals->{createTime};
    }
    if (defined $vals->{lastAccessTime}) {
      $self->{lastAccessTime} = $vals->{lastAccessTime};
    }
    if (defined $vals->{sd}) {
      $self->{sd} = $vals->{sd};
    }
    if (defined $vals->{parameters}) {
      $self->{parameters} = $vals->{parameters};
    }
    if (defined $vals->{privileges}) {
      $self->{privileges} = $vals->{privileges};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Partition';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size133 = 0;
          $self->{values} = [];
          my $_etype136 = 0;
          $xfer += $input->readListBegin(\$_etype136, \$_size133);
          for (my $_i137 = 0; $_i137 < $_size133; ++$_i137)
          {
            my $elem138 = undef;
            $xfer += $input->readString(\$elem138);
            push(@{$self->{values}},$elem138);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{dbName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{createTime});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{lastAccessTime});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{sd} = new Thrift::API::HiveClient::Metastore::StorageDescriptor();
        $xfer += $self->{sd}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size139 = 0;
          $self->{parameters} = {};
          my $_ktype140 = 0;
          my $_vtype141 = 0;
          $xfer += $input->readMapBegin(\$_ktype140, \$_vtype141, \$_size139);
          for (my $_i143 = 0; $_i143 < $_size139; ++$_i143)
          {
            my $key144 = '';
            my $val145 = '';
            $xfer += $input->readString(\$key144);
            $xfer += $input->readString(\$val145);
            $self->{parameters}->{$key144} = $val145;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{privileges} = new Thrift::API::HiveClient::Metastore::PrincipalPrivilegeSet();
        $xfer += $self->{privileges}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Partition');
  if (defined $self->{values}) {
    $xfer += $output->writeFieldBegin('values', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{values}}));
      {
        foreach my $iter146 (@{$self->{values}}) 
        {
          $xfer += $output->writeString($iter146);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{dbName}) {
    $xfer += $output->writeFieldBegin('dbName', TType::STRING, 2);
    $xfer += $output->writeString($self->{dbName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 3);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{createTime}) {
    $xfer += $output->writeFieldBegin('createTime', TType::I32, 4);
    $xfer += $output->writeI32($self->{createTime});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{lastAccessTime}) {
    $xfer += $output->writeFieldBegin('lastAccessTime', TType::I32, 5);
    $xfer += $output->writeI32($self->{lastAccessTime});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sd}) {
    $xfer += $output->writeFieldBegin('sd', TType::STRUCT, 6);
    $xfer += $self->{sd}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{parameters}) {
    $xfer += $output->writeFieldBegin('parameters', TType::MAP, 7);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{parameters}}));
      {
        while( my ($kiter147,$viter148) = each %{$self->{parameters}}) 
        {
          $xfer += $output->writeString($kiter147);
          $xfer += $output->writeString($viter148);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{privileges}) {
    $xfer += $output->writeFieldBegin('privileges', TType::STRUCT, 8);
    $xfer += $self->{privileges}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::Index;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::Index->mk_accessors( qw( indexName indexHandlerClass dbName origTableName createTime lastAccessTime indexTableName sd parameters deferredRebuild ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{indexName} = undef;
  $self->{indexHandlerClass} = undef;
  $self->{dbName} = undef;
  $self->{origTableName} = undef;
  $self->{createTime} = undef;
  $self->{lastAccessTime} = undef;
  $self->{indexTableName} = undef;
  $self->{sd} = undef;
  $self->{parameters} = undef;
  $self->{deferredRebuild} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{indexName}) {
      $self->{indexName} = $vals->{indexName};
    }
    if (defined $vals->{indexHandlerClass}) {
      $self->{indexHandlerClass} = $vals->{indexHandlerClass};
    }
    if (defined $vals->{dbName}) {
      $self->{dbName} = $vals->{dbName};
    }
    if (defined $vals->{origTableName}) {
      $self->{origTableName} = $vals->{origTableName};
    }
    if (defined $vals->{createTime}) {
      $self->{createTime} = $vals->{createTime};
    }
    if (defined $vals->{lastAccessTime}) {
      $self->{lastAccessTime} = $vals->{lastAccessTime};
    }
    if (defined $vals->{indexTableName}) {
      $self->{indexTableName} = $vals->{indexTableName};
    }
    if (defined $vals->{sd}) {
      $self->{sd} = $vals->{sd};
    }
    if (defined $vals->{parameters}) {
      $self->{parameters} = $vals->{parameters};
    }
    if (defined $vals->{deferredRebuild}) {
      $self->{deferredRebuild} = $vals->{deferredRebuild};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Index';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{indexName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{indexHandlerClass});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{dbName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{origTableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{createTime});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{lastAccessTime});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{indexTableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{sd} = new Thrift::API::HiveClient::Metastore::StorageDescriptor();
        $xfer += $self->{sd}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^9$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size149 = 0;
          $self->{parameters} = {};
          my $_ktype150 = 0;
          my $_vtype151 = 0;
          $xfer += $input->readMapBegin(\$_ktype150, \$_vtype151, \$_size149);
          for (my $_i153 = 0; $_i153 < $_size149; ++$_i153)
          {
            my $key154 = '';
            my $val155 = '';
            $xfer += $input->readString(\$key154);
            $xfer += $input->readString(\$val155);
            $self->{parameters}->{$key154} = $val155;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^10$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{deferredRebuild});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Index');
  if (defined $self->{indexName}) {
    $xfer += $output->writeFieldBegin('indexName', TType::STRING, 1);
    $xfer += $output->writeString($self->{indexName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{indexHandlerClass}) {
    $xfer += $output->writeFieldBegin('indexHandlerClass', TType::STRING, 2);
    $xfer += $output->writeString($self->{indexHandlerClass});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{dbName}) {
    $xfer += $output->writeFieldBegin('dbName', TType::STRING, 3);
    $xfer += $output->writeString($self->{dbName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{origTableName}) {
    $xfer += $output->writeFieldBegin('origTableName', TType::STRING, 4);
    $xfer += $output->writeString($self->{origTableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{createTime}) {
    $xfer += $output->writeFieldBegin('createTime', TType::I32, 5);
    $xfer += $output->writeI32($self->{createTime});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{lastAccessTime}) {
    $xfer += $output->writeFieldBegin('lastAccessTime', TType::I32, 6);
    $xfer += $output->writeI32($self->{lastAccessTime});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{indexTableName}) {
    $xfer += $output->writeFieldBegin('indexTableName', TType::STRING, 7);
    $xfer += $output->writeString($self->{indexTableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{sd}) {
    $xfer += $output->writeFieldBegin('sd', TType::STRUCT, 8);
    $xfer += $self->{sd}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{parameters}) {
    $xfer += $output->writeFieldBegin('parameters', TType::MAP, 9);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{parameters}}));
      {
        while( my ($kiter156,$viter157) = each %{$self->{parameters}}) 
        {
          $xfer += $output->writeString($kiter156);
          $xfer += $output->writeString($viter157);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{deferredRebuild}) {
    $xfer += $output->writeFieldBegin('deferredRebuild', TType::BOOL, 10);
    $xfer += $output->writeBool($self->{deferredRebuild});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::Schema;
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::Schema->mk_accessors( qw( fieldSchemas properties ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{fieldSchemas} = undef;
  $self->{properties} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{fieldSchemas}) {
      $self->{fieldSchemas} = $vals->{fieldSchemas};
    }
    if (defined $vals->{properties}) {
      $self->{properties} = $vals->{properties};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Schema';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size158 = 0;
          $self->{fieldSchemas} = [];
          my $_etype161 = 0;
          $xfer += $input->readListBegin(\$_etype161, \$_size158);
          for (my $_i162 = 0; $_i162 < $_size158; ++$_i162)
          {
            my $elem163 = undef;
            $elem163 = new Thrift::API::HiveClient::Metastore::FieldSchema();
            $xfer += $elem163->read($input);
            push(@{$self->{fieldSchemas}},$elem163);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size164 = 0;
          $self->{properties} = {};
          my $_ktype165 = 0;
          my $_vtype166 = 0;
          $xfer += $input->readMapBegin(\$_ktype165, \$_vtype166, \$_size164);
          for (my $_i168 = 0; $_i168 < $_size164; ++$_i168)
          {
            my $key169 = '';
            my $val170 = '';
            $xfer += $input->readString(\$key169);
            $xfer += $input->readString(\$val170);
            $self->{properties}->{$key169} = $val170;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Schema');
  if (defined $self->{fieldSchemas}) {
    $xfer += $output->writeFieldBegin('fieldSchemas', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{fieldSchemas}}));
      {
        foreach my $iter171 (@{$self->{fieldSchemas}}) 
        {
          $xfer += ${iter171}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{properties}) {
    $xfer += $output->writeFieldBegin('properties', TType::MAP, 2);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{properties}}));
      {
        while( my ($kiter172,$viter173) = each %{$self->{properties}}) 
        {
          $xfer += $output->writeString($kiter172);
          $xfer += $output->writeString($viter173);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::MetaException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::MetaException->mk_accessors( qw( message ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{message} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{message}) {
      $self->{message} = $vals->{message};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'MetaException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{message});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('MetaException');
  if (defined $self->{message}) {
    $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
    $xfer += $output->writeString($self->{message});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::UnknownTableException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::UnknownTableException->mk_accessors( qw( message ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{message} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{message}) {
      $self->{message} = $vals->{message};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'UnknownTableException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{message});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('UnknownTableException');
  if (defined $self->{message}) {
    $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
    $xfer += $output->writeString($self->{message});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::UnknownDBException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::UnknownDBException->mk_accessors( qw( message ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{message} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{message}) {
      $self->{message} = $vals->{message};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'UnknownDBException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{message});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('UnknownDBException');
  if (defined $self->{message}) {
    $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
    $xfer += $output->writeString($self->{message});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::AlreadyExistsException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::AlreadyExistsException->mk_accessors( qw( message ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{message} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{message}) {
      $self->{message} = $vals->{message};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'AlreadyExistsException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{message});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('AlreadyExistsException');
  if (defined $self->{message}) {
    $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
    $xfer += $output->writeString($self->{message});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::InvalidObjectException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::InvalidObjectException->mk_accessors( qw( message ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{message} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{message}) {
      $self->{message} = $vals->{message};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'InvalidObjectException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{message});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('InvalidObjectException');
  if (defined $self->{message}) {
    $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
    $xfer += $output->writeString($self->{message});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::NoSuchObjectException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::NoSuchObjectException->mk_accessors( qw( message ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{message} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{message}) {
      $self->{message} = $vals->{message};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'NoSuchObjectException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{message});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('NoSuchObjectException');
  if (defined $self->{message}) {
    $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
    $xfer += $output->writeString($self->{message});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::IndexAlreadyExistsException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::IndexAlreadyExistsException->mk_accessors( qw( message ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{message} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{message}) {
      $self->{message} = $vals->{message};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'IndexAlreadyExistsException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{message});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('IndexAlreadyExistsException');
  if (defined $self->{message}) {
    $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
    $xfer += $output->writeString($self->{message});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::InvalidOperationException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::InvalidOperationException->mk_accessors( qw( message ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{message} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{message}) {
      $self->{message} = $vals->{message};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'InvalidOperationException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{message});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('InvalidOperationException');
  if (defined $self->{message}) {
    $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
    $xfer += $output->writeString($self->{message});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package
   Thrift::API::HiveClient::Metastore::ConfigValSecurityException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
Thrift::API::HiveClient::Metastore::ConfigValSecurityException->mk_accessors( qw( message ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{message} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{message}) {
      $self->{message} = $vals->{message};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ConfigValSecurityException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{message});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ConfigValSecurityException');
  if (defined $self->{message}) {
    $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
    $xfer += $output->writeString($self->{message});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

1;
